

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

namespace Assets.Scenes.MirrorTest
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Xml;

	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class Entities : Document, IEquatable<Entities>, IComparable, IComparable<Entities>
	{
		private readonly int hashCode;
		private readonly int id;
		private readonly string name;
		private readonly float walkSpeed;

		public int Id { get { return this.id; } }
		public string Name { get { return this.name; } }
		public float WalkSpeed { get { return this.walkSpeed; } }

		public Entities(int id, string name, float walkSpeed)
		{
			this.id = id;
			this.name = name;
			this.walkSpeed = walkSpeed;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(GameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(GameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Entities other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Entities == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Entities)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.id, other.id)
				&& AreEquals(this.name, other.name)
				&& AreEquals(this.walkSpeed, other.walkSpeed)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Entities);
		}

		public int CompareTo(Entities other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(Entities value1, Entities value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Entities value1, Entities value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.id)
				+ GetHashCodeFor(this.name)
				+ GetHashCodeFor(this.walkSpeed)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.id).Append(", ");
				sb.Append("Name: ").Append(this.name).Append(", ");
				sb.Append("Walk Speed: ").Append(this.walkSpeed).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class ProjectSettings : Document, IEquatable<ProjectSettings>, IComparable, IComparable<ProjectSettings>
	{
		private readonly int hashCode;
		private readonly string id;
		private readonly string name;
		private readonly string primaryLanguage;
		private readonly string languages;
		private readonly string copyright;

		public string Id { get { return this.id; } }
		public string Name { get { return this.name; } }
		public string PrimaryLanguage { get { return this.primaryLanguage; } }
		public string Languages { get { return this.languages; } }
		public string Copyright { get { return this.copyright; } }

		public ProjectSettings(string id, string name, string primaryLanguage, string languages, string copyright)
		{
			this.id = id;
			this.name = name;
			this.primaryLanguage = primaryLanguage;
			this.languages = languages;
			this.copyright = copyright;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(GameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(GameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(ProjectSettings other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is ProjectSettings == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (ProjectSettings)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.id, other.id)
				&& AreEquals(this.name, other.name)
				&& AreEquals(this.primaryLanguage, other.primaryLanguage)
				&& AreEquals(this.languages, other.languages)
				&& AreEquals(this.copyright, other.copyright)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ProjectSettings);
		}

		public int CompareTo(ProjectSettings other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(ProjectSettings value1, ProjectSettings value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(ProjectSettings value1, ProjectSettings value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.id)
				+ GetHashCodeFor(this.name)
				+ GetHashCodeFor(this.primaryLanguage)
				+ GetHashCodeFor(this.languages)
				+ GetHashCodeFor(this.copyright)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.id).Append(", ");
				sb.Append("Project Name: ").Append(this.name).Append(", ");
				sb.Append("Primary Language: ").Append(this.primaryLanguage).Append(", ");
				sb.Append("Languages: ").Append(this.languages).Append(", ");
				sb.Append("Copyright: ").Append(this.copyright).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}



	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public partial class GameData
	{
		public const string GeneratorName = "Charon";
		public const string GeneratorVersion = "2020.1.1.0";

		#region Storage fields
		private ReadOnlyList<Entities> rootEntities;
		private ReadOnlyList<Entities> allEntities;
		private ReadOnlyDictionary<int, Entities> allEntitiesById;
		private ReadOnlyDictionary<string, Entities> allEntitiesByName;
		private ReadOnlyList<ProjectSettings> rootProjectSettings;
		private ReadOnlyList<ProjectSettings> allProjectSettings;
		private ReadOnlyDictionary<string, ProjectSettings> allProjectSettingsById;
		#endregion

		private ReadOnlyCollection<String> languages = new ReadOnlyCollection<String>(new String[] { "en-US" });
#pragma warning disable 0414 // The variable `primaryLanguage, changeNumber' is declared but never used
		private string primaryLanguage = "en-US";
		private int changeNumber = 0;
#pragma warning restore 0414

		public ReadOnlyCollection<string> SupportedLanguages { get { return this.languages; } }
		public Func<string, object, Document> FindDocument { get; private set;}


		public GameData(Stream data, Format format, Stream[] patches = null, Encoding encoding = null, bool leaveOpen = false)
		{
			if (data == null) throw new ArgumentNullException("data");

			if (encoding == null) encoding = Encoding.UTF8;


			this.FindDocument = this.FindDocumentInternal;

			switch(format)
			{
				case Format.Json: this.ReadJson(this, data, patches, encoding, leaveOpen); break;
				case Format.Bson: this.ReadBson(this, data, patches, encoding, leaveOpen); break;
				case Format.Xml: this.ReadXml(this, data, patches, encoding, leaveOpen); break;
				case Format.MessagePack: this.ReadMessagePack(this, data, patches, encoding, leaveOpen); break;
				default: throw new ArgumentException(string.Format("Unknown/Unsupported data format specified '{0}'.", format), "format");
			}

#pragma warning disable 0162 // Unreachable code detected
			this.Initialize();
#pragma warning restore 0162
		}

		private void Initialize()
		{
			if (this.rootEntities == null) this.rootEntities = ReadOnlyList<Entities>.Empty;
			if (this.rootProjectSettings == null) this.rootProjectSettings = ReadOnlyList<ProjectSettings>.Empty;

			this.FindAllDocuments();

			this.allEntitiesById = ToDictionarySkippingNullKeys(this.allEntities, document => document.Id);
			this.allEntitiesByName = ToDictionarySkippingNullKeys(this.allEntities, document => document.Name);
			this.allProjectSettingsById = ToDictionarySkippingNullKeys(this.allProjectSettings, document => document.Id);

			this.BeforeInitialize();

			foreach(var document in this.EnumerateAll())
			{
				document.Init(this, this.primaryLanguage);
			}

			this.OnInitialize();
		}

		partial void BeforeInitialize();
		partial void OnInitialize();

		#region Accessors
		// Entities -> Id
		public Entities GetEntities(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(Entities);
			if (this.allEntitiesById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Entities with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasEntities(int id)
		{
			ThrowIfNull(id, "id");

			return this.allEntitiesById.ContainsKey(id);
		}
		public Entities FindEntities(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(Entities);
			this.allEntitiesById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetEntities(int id, out Entities value)
		{
			ThrowIfNull(id, "id");

			return this.allEntitiesById.TryGetValue(id, out value);
		}
		// Entities -> Name
		public Entities GetEntitiesByName(string name)
		{
			ThrowIfNull(name, "name");

			var value = default(Entities);
			if (this.allEntitiesByName.TryGetValue(name, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Entities with Name '{0}'.", name) ,"name");
			return value;
		}
		public bool HasEntitiesWithName(string name)
		{
			ThrowIfNull(name, "name");

			return this.allEntitiesByName.ContainsKey(name);
		}
		public Entities FindEntitiesByName(string name)
		{
			ThrowIfNull(name, "name");

			var value = default(Entities);
			this.allEntitiesByName.TryGetValue(name, out value);
			return value;
		}
		public bool TryGetEntitiesByName(string name, out Entities value)
		{
			ThrowIfNull(name, "name");

			return this.allEntitiesByName.TryGetValue(name, out value);
		}
		public ReadOnlyList<Entities> GetEntities(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootEntities;
			else
				return this.allEntities;
		}
		// ProjectSettings -> Id
		public ProjectSettings GetProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(ProjectSettings);
			if (this.allProjectSettingsById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find ProjectSettings with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			return this.allProjectSettingsById.ContainsKey(id);
		}
		public ProjectSettings FindProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(ProjectSettings);
			this.allProjectSettingsById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetProjectSettings(string id, out ProjectSettings value)
		{
			ThrowIfNull(id, "id");

			return this.allProjectSettingsById.TryGetValue(id, out value);
		}
		public ReadOnlyList<ProjectSettings> GetProjectSettings(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootProjectSettings;
			else
				return this.allProjectSettings;
		}
		// ProjectSettings -> Instance
		private ProjectSettings theProjectSettings;
		public ProjectSettings ProjectSettings 
		{ 
			get 
			{ 
				if (this.theProjectSettings != null)
					return this.theProjectSettings;

				switch(this.rootProjectSettings.Count)
				{
					case 0: throw new InvalidOperationException("Unable to find ProjectSettings document. Please create ProjectSettings document before using this property.");
					case 1: return this.theProjectSettings = this.rootProjectSettings[0];
					default: throw new InvalidOperationException("There is a multiple variants of ProjectSettings document. Please remove the excess before using this property.");
				}
			}
		}
		#endregion

		public IEnumerable<Document> GetAllDocuments()
		{
			return this.EnumerateAll();
		}

		public void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");

			foreach(var document in this.EnumerateAll())
				document.SetLanguage(languageId);
		}

		private Document FindDocumentInternal(string entityId, object id)
		{
			if (entityId == null) throw new ArgumentNullException("entityId");

#pragma warning disable 1522 // Empty switch block
			switch (entityId)
			{
				case "Entities":
				case "2cd5b55e05a991db0600005c": return this.GetEntities((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "ProjectSettings":
				case "55a4f32faca22e191098f3d9": return this.GetProjectSettings((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
			}
#pragma warning restore 1522
			throw new System.ArgumentException(string.Format("Unable find Entity with id '{0}'.", entityId) ,"entityId");
		}

		private IEnumerable<Document> EnumerateAll()
		{
			var i = 0;
			var end = 0;
			for (i = 0, end = this.allEntities.Count; i < end; i++)
			{
				yield return this.allEntities[i];
			}
			for (i = 0, end = this.allProjectSettings.Count; i < end; i++)
			{
				yield return this.allProjectSettings[i];
			}
			yield break;
		}

		private IEnumerable<Document> EnumerateRoots()
		{
			var i = 0;
			var end = 0;
			for (i = 0, end = this.rootEntities.Count; i < end; i++)
			{
				yield return this.rootEntities[i];
			}
			for (i = 0, end = this.rootProjectSettings.Count; i < end; i++)
			{
				yield return this.rootProjectSettings[i];
			}

			yield break;
		}

		private static void ThrowIfNull<T>(T value, string paramName)
		{
			if (value == null) throw new ArgumentNullException(paramName);
		}

		private static object ChangeType(object value, Type toType, IFormatProvider format)
		{
			if (toType.IsEnum && Enum.GetUnderlyingType(toType) == typeof(ulong))
				return Enum.ToObject(toType, Convert.ToUInt64(value, format));
			if (toType.IsEnum)
				return Enum.ToObject(toType, Convert.ToInt64(value, format));
			else
				return System.Convert.ChangeType(value, toType, format);
		}
		private static ReadOnlyDictionary<KeyT, ValueT> ToDictionarySkippingNullKeys<KeyT, ValueT>(ReadOnlyList<ValueT> list, Func<ValueT, KeyT> keySelector)
			where ValueT : Document
		{
			if (list == null) throw new ArgumentNullException("list");
			if (keySelector == null) throw new ArgumentNullException("keySelector");

			if (list.Count == 0)
				return ReadOnlyDictionary<KeyT, ValueT>.Empty;

			var dictionary = new Dictionary<KeyT, ValueT>(list.Count);
			if (typeof(KeyT).IsValueType)
			{
				for (var i = 0; i < list.Count; i++)
				{
					var value = list[i];
					var key = keySelector(value);
					dictionary[key] = value;
				}
			}
			else
			{
				for (var i = 0; i < list.Count; i++)
				{
					var value = list[i];
					var key = keySelector(value);
					if (Object.ReferenceEquals(key, default(KeyT))) continue;
					dictionary[key] = value;
				}
			}
			return new ReadOnlyDictionary<KeyT, ValueT>(dictionary);
		}


		#region Visitors
		public void ApplyVisitor(Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");
			
			foreach(var document in this.EnumerateRoots())
				document.Apply(visitor);
		}

		private void FindAllDocuments()
		{
			var findingVisitor = new FindingVisitor();
			this.ApplyVisitor(findingVisitor);


			if (findingVisitor.AllEntities != null)
			{
				var list = findingVisitor.AllEntities;
				list.Sort();
				this.allEntities = new ReadOnlyList<Entities>(list);
			}
			else
			{
				this.allEntities = ReadOnlyList<Entities>.Empty;
			}

			if (findingVisitor.AllProjectSettings != null)
			{
				var list = findingVisitor.AllProjectSettings;
				list.Sort();
				this.allProjectSettings = new ReadOnlyList<ProjectSettings>(list);
			}
			else
			{
				this.allProjectSettings = ReadOnlyList<ProjectSettings>.Empty;
			}
		}

		public class Visitor
		{
			public virtual void Visit(Entities value)
			{
			}
			public virtual void Visit(ProjectSettings value)
			{
			}
		}

		private class FindingVisitor : Visitor
		{
			public List<Entities> AllEntities;
			public List<ProjectSettings> AllProjectSettings;
		
			public override void Visit(Entities value) 
			{ 
				if (this.AllEntities == null)
					this.AllEntities = new List<Entities>(6);

				this.AllEntities.Add(value); 
			}
			public override void Visit(ProjectSettings value) 
			{ 
				if (this.AllProjectSettings == null)
					this.AllProjectSettings = new List<ProjectSettings>(50);

				this.AllProjectSettings.Add(value); 
			}
		}
		#endregion

		#region Serialization


		#region Serialization: Common Types
		private static readonly IFormatProvider FormatProvider = System.Globalization.CultureInfo.InvariantCulture;
		private static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		private static readonly StringLookupTable SharedStringsLookupTable = null;

		public enum Format
		{
			Json,
			Bson,
			Xml,
			MessagePack
		}

		private abstract class Reader
		{
			protected readonly StringLookupTable stringLookupTable = SharedStringsLookupTable;

			public abstract ReaderNode Node { get; }

			public abstract int LineNumber { get; }
			public abstract int ColumnNumber { get; }

			public abstract bool NextToken();

			public void ReadGameData(GameData gameData, Dictionary<string, object> patch = null)
			{
				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var memberName = this.ReadMember();
					switch(memberName)
					{
						case "ChangeNumber":
							gameData.changeNumber = (Int32)this.Node.AsInt32;
							this.NextToken();
						break;
						case "Collections":
							var collectionPatch = GetDocument(patch, "Collections");
							this.ReadObjectBegin();
							while(this.Node.Token != ReaderToken.EndOfObject)
							{
								var collectionName = this.ReadMember();
								switch (collectionName.Length)
								{
									case 8:
										switch(collectionName)
										{
											case "Entities":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var entitiesPatch = GetDocumentCollection(collectionPatch, "Entities") ?? GetDocumentCollection(collectionPatch, "2cd5b55e05a991db0600005c");

												gameData.rootEntities = this.ReadEntitiesCollection(entitiesPatch, 1, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 15:
										switch(collectionName)
										{
											case "ProjectSettings":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var projectSettingsPatch = GetDocumentCollection(collectionPatch, "ProjectSettings") ?? GetDocumentCollection(collectionPatch, "55a4f32faca22e191098f3d9");

												gameData.rootProjectSettings = this.ReadProjectSettingsCollection(projectSettingsPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									default:
										this.ReadAny();
										break;
								}
							}
							this.ReadObjectEnd();
							return;
						default:
							this.ReadAny();
							break;
					}
				}

				this.ReadObjectEnd();

				// update language list
				var projectSettings = gameData.rootProjectSettings.FirstOrDefault();
				if (projectSettings != null && string.IsNullOrEmpty(projectSettings.Languages) == false)
				{
						var languages = new List<String>(projectSettings.Languages.Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries));
						if (string.IsNullOrEmpty(projectSettings.PrimaryLanguage) == false)
						{
							gameData.primaryLanguage = projectSettings.PrimaryLanguage;
						}
						else if (languages.Count > 0)
						{
							gameData.primaryLanguage = languages[0];
						}
						else
						{
							gameData.primaryLanguage = "EN-US";
						}
						languages.Remove(projectSettings.PrimaryLanguage);
						languages.Add(projectSettings.PrimaryLanguage);
						languages.Sort(StringComparer.OrdinalIgnoreCase);

						gameData.languages = new ReadOnlyCollection<String>(languages);
				}
			}

			private ReadOnlyList<Entities> ReadEntitiesCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Entities>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadEntities(collectionPatch);
					if (collection == null) { collection = new List<Entities>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, Entities>(collection, collectionPatch, d => CreateEntities(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Entities>.Create(collection);
			}
			private Entities CreateEntities(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var id = GetAndCovertValue<int>(values, "Id");
				var name = GetAndCovertValue<string>(values, "Name");
				var walkSpeed = GetAndCovertValue<float>(values, "WalkSpeed");

				return new Entities(id, name, walkSpeed);
			}
			private Entities ReadEntities(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var id = default(int);
				var name = default(string);
				var walkSpeed = default(float);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "Entities");

									this.ThrowIfNotValue();

									id = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(id, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of Text type", "Name", "Entities");

									this.ThrowIfNotValue();

									name = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "WalkSpeed":
								{
									this.ThrowIfNull("value of Number type", "WalkSpeed", "Entities");

									this.ThrowIfNotValue();

									walkSpeed = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref id);
					PatchValue(documentPatch, "Name", ref name);
					PatchValue(documentPatch, "WalkSpeed", ref walkSpeed);
				}

				return new Entities(id, name, walkSpeed);
			}

			private ReadOnlyList<ProjectSettings> ReadProjectSettingsCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<ProjectSettings>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadProjectSettings(collectionPatch);
					if (collection == null) { collection = new List<ProjectSettings>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, ProjectSettings>(collection, collectionPatch, d => CreateProjectSettings(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<ProjectSettings>.Create(collection);
			}
			private ProjectSettings CreateProjectSettings(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var id = GetAndCovertValue<string>(values, "Id");
				var name = GetAndCovertValue<string>(values, "Name");
				var primaryLanguage = GetAndCovertValue<string>(values, "PrimaryLanguage");
				var languages = GetAndCovertValue<string>(values, "Languages");
				var copyright = GetAndCovertValue<string>(values, "Copyright");

				return new ProjectSettings(id, name, primaryLanguage, languages, copyright);
			}
			private ProjectSettings ReadProjectSettings(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var id = default(string);
				var name = default(string);
				var primaryLanguage = default(string);
				var languages = default(string);
				var copyright = default(string);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "ProjectSettings");

									this.ThrowIfNotValue();

									id = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(id, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of Text type", "Name", "ProjectSettings");

									this.ThrowIfNotValue();

									name = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Languages":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									languages = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								case "Copyright":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									copyright = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 15:
						{
							switch (attributeName)
							{
								case "PrimaryLanguage":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									primaryLanguage = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref id);
					PatchValue(documentPatch, "Name", ref name);
					PatchValue(documentPatch, "PrimaryLanguage", ref primaryLanguage);
					PatchValue(documentPatch, "Languages", ref languages);
					PatchValue(documentPatch, "Copyright", ref copyright);
				}

				return new ProjectSettings(id, name, primaryLanguage, languages, copyright);
			}
			public Dictionary<string, object> ReadDocument()
			{
				return this.ReadObject();
			}
			
			private void ReadArrayBegin(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.BeginArray)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
				}
				if (this.IsEndOfStream())
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
				}

				if (nextToken)
					this.NextToken();
			}
			private void ReadArrayEnd(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.EndOfArray)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
				}

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}
			}
			private void ReadObjectBegin(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.BeginObject)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
				}

				if (this.IsEndOfStream())
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
				}

				if (nextToken)
				{
					this.NextToken();
				}
			}
			private void ReadObjectEnd(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.EndOfObject)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
				}

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}
			}
			private string ReadMember(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
				}

				var memberName = this.Node.AsString;

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}

				return memberName;
			}

			protected object ReadAny(bool nextToken = true)
			{
				var value = default(object);
				switch(this.Node.Token)
				{
					case ReaderToken.BeginArray: value = this.ReadArray(false); break;
					case ReaderToken.BeginObject: value = this.ReadObject(false); break;
					case ReaderToken.Null: value = null; break;
					case ReaderToken.Value: value = this.Node.AsObject; break;
					default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
				}

				if (nextToken)
				{
					this.NextToken();
				}

				return value;
			}
			private List<object> ReadArray(bool nextToken = true)
			{
				var list = default(List<object>);
				var itemIndex = 0;
				var item1 = default(object);
				var item2 = default(object);
				var item3 = default(object);
				var item4 = default(object);

				this.ReadArrayBegin();
				while(this.Node.Token != ReaderToken.EndOfArray)
				{
					var value = this.ReadAny();

					if (list == null)
					{
						switch (itemIndex)
						{
							case 0:
								item1 = value;
								itemIndex = 1;
								continue;
							case 1:
								item2 = value;
								itemIndex = 2;
								continue;
							case 2:
								item3 = value;
								itemIndex = 3;
								continue;
							case 3:
								item4 = value;
								itemIndex = 4;
								continue;
							default:
								list = new List<object>(itemIndex + 1);
								list.Add(item1);
								list.Add(item2);
								list.Add(item3);
								list.Add(item4);
								break;
						}
					}

					list.Add(value);
				}
				this.ReadArrayEnd(nextToken);

				if (itemIndex == 0)
				{
					list = new List<object>(1);
				}
				else if (list == null)
				{
					list = new List<object>(itemIndex);

					if (itemIndex > 0) { list.Add(item1); }
					if (itemIndex > 1) { list.Add(item2); }
					if (itemIndex > 2) { list.Add(item3); }
					if (itemIndex > 3) { list.Add(item4); }
				}

				return list;
			}
			private Dictionary<string, object> ReadObject(bool nextToken = true)
			{
				var keyValueIndex = 0;
				var keyValuePair1 = default(KeyValuePair<string, object>);
				var keyValuePair2 = default(KeyValuePair<string, object>);
				var keyValuePair3 = default(KeyValuePair<string, object>);
				var keyValuePair4 = default(KeyValuePair<string, object>);
				var dictionary = default(Dictionary<string, object>);

				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					var value = this.ReadAny();

					if (dictionary == null)
					{
						switch (keyValueIndex)
						{
							case 0:
								keyValuePair1 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 1;
								continue;
							case 1:
								keyValuePair2 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 2;
								continue;
							case 2:
								keyValuePair3 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 3;
								continue;
							case 3:
								keyValuePair4 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 4;
								continue;
							default:
								dictionary = new Dictionary<string, object>(keyValueIndex + 1);
								dictionary[keyValuePair1.Key] = keyValuePair1.Value;
								dictionary[keyValuePair2.Key] = keyValuePair2.Value;
								dictionary[keyValuePair3.Key] = keyValuePair3.Value;
								dictionary[keyValuePair4.Key] = keyValuePair4.Value;
								break;
						}
					}

					dictionary[key] = value;
				}
				this.ReadObjectEnd(nextToken);

				
				if (keyValueIndex == 0)
				{
					dictionary = new Dictionary<string, object>(1);
				}
				else if (dictionary == null)
				{
					dictionary = new Dictionary<string, object>(keyValueIndex);
					switch (keyValueIndex)
					{					
						case 1: dictionary[keyValuePair1.Key] = keyValuePair1.Value; break;
						case 2: dictionary[keyValuePair2.Key] = keyValuePair2.Value; goto case 1;
						case 3: dictionary[keyValuePair3.Key] = keyValuePair3.Value; goto case 2;
						case 4: dictionary[keyValuePair4.Key] = keyValuePair4.Value; goto case 3;
					}
				}

				return dictionary;
			}
			private LocalizedString ReadLocalizedString(bool nextToken = true)
			{
				var locString = new LocalizedString();
				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					var value = Convert.ToString(this.ReadAny(), FormatProvider);

					if (key == "notes")
					{
						continue;
					}

					locString[key] = value;
				}
				this.ReadObjectEnd(nextToken);
				return locString;
			}
			private ReadOnlyList<DocumentReference<T>> ReadReferenceCollection<T>(bool nextToken = true) where T : Document
			{
				var referenceCollection = default(List<DocumentReference<T>>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadReference<T>();
					if (referenceCollection == null) { referenceCollection = new List<DocumentReference<T>>(5); }
					referenceCollection.Add(value);
				}
				this.ReadArrayEnd(nextToken);

				return ReadOnlyList<DocumentReference<T>>.Create(referenceCollection);
			}
			private DocumentReference<T> ReadReference<T>(bool nextToken = true) where T : Document
			{
				var reference = new DocumentReference<T>();
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					if (key == "Id")
						reference.Id = this.ReadAny();
					else
						this.ReadAny();
				}
				this.ReadObjectEnd(nextToken);
				return reference;
			}

			private bool IsEndOfStream()
			{
				return this.Node.Token == ReaderToken.EndOfStream;
			}
			private bool IsNull()
			{
				return this.Node.Token == ReaderToken.Null;
			}
			private void ThrowIfNotValue()
			{
				if (this.Node.Token != ReaderToken.Value)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
				}
			}
			private void ThrowIfNull(string expected, string attributeName, string entityName)
			{
				if (this.Node.Token == ReaderToken.Null)
				{
					throw ReaderException.UnexpectedNullValue(expected, attributeName, entityName, this);
				}
			}

			private static T GetValueAs<T>(Dictionary<string, object> values, string key, T defaultValue = default(T))
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false || valueObj is T == false)
				{
					return defaultValue;
				}
				return (T)valueObj;
			}
			private static object GetValue(Dictionary<string, object> values, string key)
			{
				if (key == null) throw new ArgumentNullException("key");

				if (values == null)
				{
					return null;
				}

				var valueObj = default(object);
				values.TryGetValue(key, out valueObj);
				return valueObj;
			}
			private static Dictionary<string, object> GetDocument(Dictionary<string, object> values, string key)
			{
				return GetValueAs<Dictionary<string, object>>(values, key);
			}
			private static T GetAndCovertValue<T>(Dictionary<string, object> values, string key, T defaultValue = default(T))
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false)
				{
					return defaultValue;
				}

				return ConvertTo<T>(valueObj);
			}
			
			private static Dictionary<string, object> GetDocumentCollection(Dictionary<string, object> values, string key)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false)
				{
					return null;
				}

				if (valueObj is Dictionary<string, object>)
				{
					return (Dictionary<string, object>)valueObj;
				}
				else if (valueObj is List<object>)
				{
					var documents = (List<object>)valueObj;
					var documentsById = new Dictionary<string, object>(documents.Count);
					foreach (var document in documents)
					{
						var id = Convert.ToString(GetValue(document as Dictionary<string, object>, "Id"), FormatProvider);
						if (string.IsNullOrEmpty(id))
						{
							continue;
						}
						documentsById[id] = document;
					}
					return documentsById;
				}
				else
				{
					return null;
				}
			}
			private static void PatchValue<T>(Dictionary<string, object> values, string key, ref T value)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				value = ConvertTo<T>(valueObj);
			}
			private void PatchCollection<IdType, EntityT>(List<EntityT> collection, Dictionary<string, object> collectionPatch, Func<Dictionary<string, object>, EntityT> constructor, Func<EntityT, IdType> getId, bool isRootCollection)
			{
				if (collection == null) throw new ArgumentNullException("collection");
				if (collectionPatch == null) throw new ArgumentNullException("collectionPatch");
				if (constructor == null) throw new ArgumentNullException("constructor");
				if (getId == null) throw new ArgumentNullException("getId");

				var collectionIndex = 0;
				var idComparer = Comparer<IdType>.Default;
				var patchIndex = 0;
				foreach (var kv in collectionPatch)
				{
					var id = ConvertTo<IdType>(kv.Key);
					collectionIndex = -1;
					for (int k = 0; k < collection.Count; k++)
					{
						if (idComparer.Compare(getId(collection[k]), id) != 0)
						{
							continue;
						}
						collectionIndex = k;
						break;
					}

					if (kv.Value == null && collectionIndex != -1)
					{
						// remove document
						collection.RemoveAt(collectionIndex);
					}
					else if (kv.Value is Dictionary<string, object> && collectionIndex == -1)
					{
						// create document
						var document = (Dictionary<string, object>)kv.Value;
						collection.Add(constructor(document));
					}
					else if (patchIndex != collectionIndex && collectionIndex != -1 && isRootCollection == false)
					{
						// re-order document
						var document = collection[collectionIndex];
						collection.RemoveAt(collectionIndex);
						collection.Insert(patchIndex, document);
					}

					patchIndex++;
				}
			}
			private static void PatchReference<T>(Dictionary<string, object> values, string key, ref DocumentReference<T> value) where T : Document
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				var newReference = valueObj as Dictionary<string, object>;
				var newReferenceId = default(object);
				if (newReference == null || newReference.TryGetValue("Id", out newReferenceId) == false || newReferenceId == null) 
				{
					value = null;
					return;
				}
				value = new DocumentReference<T>() { Id = newReferenceId };
			}
			private static void PatchReferenceCollection<T>(Dictionary<string, object> values, string key, ref ReadOnlyList<DocumentReference<T>> value) where T : Document
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				if (valueObj is Dictionary<string, object>)
				{
					var referenceById = (Dictionary<string, object>)valueObj;
					var collection = new List<DocumentReference<T>>(referenceById.Count);

					foreach(var kv in referenceById)
					{
						if (kv.Value == null)
						{
							continue;
						}
						collection.Add(new DocumentReference<T> { Id = kv.Key });
					}

					value = ReadOnlyList<DocumentReference<T>>.Create(collection);
				}
				else if (valueObj is List<object>)
				{
					var referenceList = (List<object>)valueObj;
					var collection = new List<DocumentReference<T>>(referenceList.Count);

					foreach(var reference in referenceList)
					{
						if (reference == null || reference is Dictionary<string, object> == false)
						{
							continue;
						}
						var id = GetValue((Dictionary<string, object>)reference, "Id");
						if (id == null)
						{
							continue;
						}
						collection.Add(new DocumentReference<T> { Id = id });
					}

					value = ReadOnlyList<DocumentReference<T>>.Create(collection);
				}
			}
			private static void PatchLocalizedString(Dictionary<string, object> values, string key, ref LocalizedString value)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				var newLocalization = valueObj as Dictionary<string, object>;
				if (newLocalization == null) 
				{
					value = null;
					return;
				}

				value = value ?? new LocalizedString();
				foreach (var kv in newLocalization)
				{
					if (kv.Value == null)
					{
						value[kv.Key] = null;
					}
					else
					{
						value[kv.Key] = Convert.ToString(kv.Value, FormatProvider);
					}
				}
			}
			private static T ConvertTo<T>(object valueObj)
			{
				if (valueObj is T)
				{
					return (T)valueObj;
				}

				var nullableType = Nullable.GetUnderlyingType(typeof(T));
				var valueType = nullableType ?? typeof(T);
				if (valueObj == null)
				{
					if (typeof(T).IsValueType && nullableType == null)
					{
						throw new InvalidOperationException(string.Format("Unable to convert null value to type '{0}'.", typeof(T)));
					}
					return default(T);
				}
				else if (valueType.IsEnum)
				{
					return (T)Enum.Parse(valueType, Convert.ToString(valueObj, FormatProvider), true);
				}
				else
				{
					return (T)Convert.ChangeType(valueObj, valueType, FormatProvider);
				}
			}

			public override string ToString()
			{
				return this.Node.ToString();
			}
		}

		private struct ReaderNode
		{
			private readonly object value;

			public readonly ReaderToken Token;
			public readonly Type ValueType;

			public bool HasValue { get { return this.ValueType != typeof(void); } }

			public ReaderNode(ReaderToken token)
			{
				this.Token = token;
				this.value = null;
				this.ValueType = typeof(void);
			}
			public ReaderNode(ReaderToken token, object value)
			{
				if (value == null) throw new ArgumentNullException("value");

				this.Token = token;
				this.value = value;
				this.ValueType = value is IStrongBox ? ((IStrongBox)value).ValueType : value.GetType();
			}

			public bool AsBoolean
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsBoolean;
					return Convert.ToBoolean(this.value, FormatProvider);
				}
			}
			public byte AsByte
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsByte;
					return Convert.ToByte(this.value, FormatProvider);
				}
			}
			public short AsInt16
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt16;
					return Convert.ToInt16(this.value, FormatProvider);
				}
			}
			public int AsInt32
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt32;
					return Convert.ToInt32(this.value, FormatProvider);
				}
			}
			public long AsInt64
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt64;
					return Convert.ToInt64(this.value, FormatProvider);
				}
			}
			public sbyte AsSByte
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsSByte;
					return Convert.ToSByte(this.value, FormatProvider);
				}
			}
			public ushort AsUInt16
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt16;
					return Convert.ToUInt16(this.value, FormatProvider);
				}
			}
			public uint AsUInt32
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt32;
					return Convert.ToUInt32(this.value, FormatProvider);
				}
			}
			public ulong AsUInt64
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt64;
					return Convert.ToUInt64(this.value, FormatProvider);
				}
			}
			public float AsSingle
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsSingle;
					return Convert.ToSingle(this.value, FormatProvider);
				}
			}
			public double AsDouble
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsDouble;
					return Convert.ToDouble(this.value, FormatProvider);
				}
			}
			public decimal AsDecimal
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsDecimal;
					return Convert.ToDecimal(this.value, FormatProvider);
				}
			}
			public string AsString
			{
				get
				{
					var value = this.value;
					if (this.value is IStrongBox) value = (this.value as IStrongBox).AsObject;
					return Convert.ToString(value, FormatProvider);
				}
			}
			public DateTime AsDateTime
			{
				get
				{
					var dateTimeStr = this.AsString;
					var date = DateTime.ParseExact(dateTimeStr, DateTimeFormats, FormatProvider, System.Globalization.DateTimeStyles.RoundtripKind);
					return date;
				}
			}
			public TimeSpan AsTimeSpan
			{
				get
				{
					var timeSpanStr = this.AsString;
					var timeSpan = TimeSpan.Parse(timeSpanStr);
					return timeSpan;
				}
			}
			public object AsObject
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsObject;
					return this.value;
				}
			}

			public override string ToString()
			{
				return string.Format(FormatProvider, "{0}:{1}", this.Token, this.value);
			}
		}

		private interface IStrongBox
		{
			bool AsBoolean { get; }
			byte AsByte { get; }
			short AsInt16 { get; }
			int AsInt32 { get; }
			long AsInt64 { get; }
			sbyte AsSByte { get; }
			ushort AsUInt16 { get; }
			uint AsUInt32 { get; }
			ulong AsUInt64 { get; }
			float AsSingle { get; }
			double AsDouble { get; }
			decimal AsDecimal { get; }
			Type ValueType { get; }
			object AsObject { get; }

			void Store<T>(T value);
		}

		private sealed class StrongBox<ValueT> : IStrongBox
		{
			private static readonly Type ValueType = typeof(ValueT);

			private readonly IFormatProvider formatProvider;

			public ValueT Value;

			public StrongBox(ValueT value, IFormatProvider formatProvider)
				: this(formatProvider)
			{
				this.Value = value;
			}
			public StrongBox(IFormatProvider formatProvider)
			{
				if (formatProvider == null) throw new ArgumentNullException("formatProvider");

				this.formatProvider = formatProvider;
			}

			Type IStrongBox.ValueType { get { return ValueType; } }
			public bool AsBoolean { get	{ return Convert.ToBoolean((object)Value, this.formatProvider);	} }
			public byte AsByte { get { return Convert.ToByte((object)Value, this.formatProvider); } }
			public short AsInt16 { get { return Convert.ToInt16((object)Value, this.formatProvider); } }
			public int AsInt32 { get { return Convert.ToInt32((object)Value, this.formatProvider); } }
			public long AsInt64 { get { return Convert.ToInt64((object)Value, this.formatProvider); } }
			public sbyte AsSByte { get { return Convert.ToSByte((object)Value, this.formatProvider); } }
			public ushort AsUInt16 { get { return Convert.ToUInt16((object)Value, this.formatProvider); } }
			public uint AsUInt32 { get { return Convert.ToUInt32((object)Value, this.formatProvider); } }
			public ulong AsUInt64 { get { return Convert.ToUInt64((object)Value, this.formatProvider); } }
			public float AsSingle { get { return Convert.ToSingle((object)Value, this.formatProvider); } }
			public double AsDouble { get { return Convert.ToDouble((object)Value, this.formatProvider); } }
			public decimal AsDecimal { get { return Convert.ToDecimal((object)Value, this.formatProvider); } }
			public object AsObject { get { return this.Value; } }

			public void Store<T>(T value)
			{
				var type = typeof(T);
				if (type != ValueType)
				{
					throw new ArgumentException(string.Format("Unable to store value of type '{0}' in container of type '{1}'", typeof(ValueT), type));
				}
				this.Value = (ValueT)(object)value;
			}

			public override string ToString()
			{
				return Convert.ToString(this.Value, this.formatProvider);
			}
		}

		private enum ReaderToken
		{
			None = 0,
			BeginArray,
			EndOfArray,
			BeginObject,
			EndOfObject,
			Member,
			Null,
			Value,
			Comment,
			EndOfStream
		}

		public sealed class StringSet
		{
			public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

			private readonly ulong[] keys;
			private readonly StringSet[] subSets;
			private readonly string[] values;

			public StringSet(ulong[] keys, StringSet[] subSets)
			{
				if(keys == null) throw new ArgumentNullException("keys");
				if(subSets == null) throw new ArgumentNullException("subSets");
				if(subSets.Length != keys.Length) throw new ArgumentException("invalid sets", "keys");

				this.keys = keys;
				this.subSets = subSets;
			}
			public StringSet(ulong[] keys, string[] values)
			{
				if(keys == null) throw new ArgumentNullException("keys");
				if(values == null) throw new ArgumentNullException("values");
				if(values.Length != keys.Length) throw new ArgumentException("invalid sets", "keys");

				this.keys = keys;
				this.values = values;
			}

			public bool TryNarrow(ulong octet, out StringSet value)
			{
				var subSetIndex = 0;
				switch (this.keys.Length)
				{
					case 1: subSetIndex = this.keys[0] == octet ? 0 : -1; break;
					case 2: subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1; break;
					case 3:
					case 4:
					case 5: subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length); break;
					default: subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer); break;
				}

				if (subSetIndex < 0)
				{
					value =  null;
					return false;
				}
				value = this.subSets[subSetIndex];
				return true;
			}
			public bool TryGetValue(ulong octet, out string value)
			{
				var valueIndex = 0;
				switch (this.keys.Length)
				{
					case 1: valueIndex = this.keys[0] == octet ? 0 : -1; break;
					case 2: valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1; break;
					case 3:
					case 4:
					case 5: valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length); break;
					default: valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer); break;
				}

				if (valueIndex < 0)
				{
					value = null;
					return false;
				}

				value = this.values[valueIndex];
				return value != null;
			}
		}

		public sealed class StringLookupTable
		{
			public const int MAX_STRING_SIZE = 8 * 8;

			private readonly StringSet[] table;

			public StringLookupTable(StringSet[] table)
			{
				if (table == null) throw new ArgumentNullException("table");

				this.table = table;
				Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
			}

			public bool TryGetString(byte[] bytes, int offset, int count, out string value)
			{
				const int LAST_ASCII_CHARACTER = 0x7f;

				if (bytes == null) { throw new ArgumentNullException("bytes"); }
				if (count < 0) throw new ArgumentOutOfRangeException("count");
				if (offset < 0) throw new ArgumentOutOfRangeException("offset");
				if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException("offset");

				if (count == 0)
				{
					value = string.Empty;
					return true;
				}

				value = null;
				if (count > MAX_STRING_SIZE || this.table[count] == null)
				{
					return false;
				}

				var end = offset + count;
				var octet = 0UL;
				for (var i = 0; offset + i < end; i++)
				{
					var character = bytes[offset + i];
					if (character > LAST_ASCII_CHARACTER)
					{
						return false;
					}

					if (i < 8)
					{
						octet = unchecked(octet | ((ulong)character << 8 * i));
					}
				}

				var set = this.table[count];
				var narrowOffset = 1;
				for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
				{
					if (set == null || !set.TryNarrow(octet, out set))
					{
						return false;
					}

					octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
				}
				
				return set != null && set.TryGetValue(octet, out value);
			}
			public bool TryGetString(char[] chars, int offset, int count, out string value)
			{
				const int LAST_ASCII_CHARACTER = 0x7f;

				if (chars == null) { throw new ArgumentNullException("chars"); }
				if (count < 0) throw new ArgumentOutOfRangeException("count");
				if (offset < 0) throw new ArgumentOutOfRangeException("offset");
				if (offset + count > chars.Length) throw new ArgumentOutOfRangeException("offset");

				if (count == 0)
				{
					value = string.Empty;
					return true;
				}

				value = null;
				if (count > MAX_STRING_SIZE || this.table[count] == null)
				{
					return false;
				}

				var end = offset + count;
				var octet = 0UL;
				for (var i = 0; offset + i < end; i++)
				{
					var character = chars[offset + i];
					if (character > LAST_ASCII_CHARACTER)
					{
						return false;
					}

					if (i < 8)
					{
						octet = unchecked(octet | ((ulong)character << 8 * i));
					}
				}

				var set = this.table[count];
				var narrowOffset = 1;
				for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
				{
					if (set == null || !set.TryNarrow(octet, out set))
					{
						return false;
					}

					octet = GetUInt64(chars, offset + narrowOffset * 8, end);
				}
				
				return set != null && set.TryGetValue(octet, out value);
			}

			private static ulong GetUInt64(byte[] bytes, int offset, int end)
			{
				if (offset >= end)
				{
					return 0;
				}

				switch (end - offset)
				{
					case 1: return (ulong)bytes[offset];
					case 2:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1;
					case 3:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2;
					case 4:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3;
					case 5:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4;
					case 6:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5;
					case 7:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5 |
							(ulong)bytes[offset + 6] << 8 * 6;
					default:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5 |
							(ulong)bytes[offset + 6] << 8 * 6 |
							(ulong)bytes[offset + 7] << 8 * 7;
				}
			}
			private static ulong GetUInt64(char[] chars, int offset, int end)
			{
				if (offset >= end)
				{
					return 0;
				}

				switch (end - offset)
				{
					case 1: return (ulong)chars[offset];
					case 2:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1;
					case 3:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2;
					case 4:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3;
					case 5:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4;
					case 6:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5;
					case 7:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5 |
							(ulong)chars[offset + 6] << 8 * 6;
					default:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5 |
							(ulong)chars[offset + 6] << 8 * 6 |
							(ulong)chars[offset + 7] << 8 * 7;
				}
			}
		}

		[Serializable]
		private class ReaderException : SerializationException
		{
			public int Code { get; set; }
			public int LineNumber { get; set; }
			public int ColumnNumber { get; set; }

			private ReaderException(string message, Reader reader)
				: base(message)
			{
				if (message == null) throw new ArgumentNullException("message");

				if (reader != null)
					this.Update(reader);
			}

			protected ReaderException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
				if (info == null) throw new ArgumentNullException("info");

				this.LineNumber = info.GetInt32("LineNumber");
				this.ColumnNumber = info.GetInt32("ColumnNumber");
			}

			private void Update(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				this.LineNumber = reader.LineNumber;
				this.ColumnNumber = reader.ColumnNumber;
			}

			public override void GetObjectData(SerializationInfo info, StreamingContext context)
			{
				if (info == null) throw new ArgumentNullException("info");

				info.AddValue("Code", this.Code);
				info.AddValue("LineNumber", this.LineNumber);
				info.AddValue("ColumnNumber", this.ColumnNumber);

				base.GetObjectData(info, context);
			}

			public static Exception UnexpectedEndOfStream(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Unexpected end of stream."), reader);
			}
			public static Exception UnexpectedToken(Reader reader, params ReaderToken[] expectedTokens)
			{
				if (reader == null) throw new ArgumentNullException("reader");
				if (expectedTokens == null) throw new ArgumentNullException("expectedTokens");

				var tokensStr = default(string);
				if (expectedTokens.Length == 0)
				{
					tokensStr = "<no tokens>";
				}
				else
				{
					var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
					tokensStr = String.Join(", ", tokens);
				}

				return new ReaderException(string.Format("Expected one of there '{2}' but found '{0}'({1}).", reader.Node.Token, reader.Node.ValueType.Name, tokensStr), reader);
			}
			public static Exception UnknownEscapeSequence(string escape, Reader reader)
			{
				if (escape == null) throw new ArgumentNullException("escape");
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown escape sequence '{0}'.", escape),reader);
			}
			public static Exception UnterminatedStringLiteral(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unterminated string literal."), reader);
			}
			public static Exception UnknownNotation(Reader reader, string notation)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown notation '{0}'.", notation), reader);
			}
			public static Exception StringLiteralIsTooLong(Reader reader, int size, int maxSize)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("String literal is too long '{0}'. Maximum size is {1}.", size, maxSize), reader);
			}
			public static Exception BinaryDataIsTooLong(Reader reader, int size, int maxSize)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Binary data is too long '{0}'. Maximum size is {1}.", size, maxSize), reader);
			}
			public static Exception ReadingBrokenDocument(Reader reader, string additionalInformation)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Failed to continue deserialize because document's structure is invalid. Additional information: {0}", additionalInformation), reader);
			}
			public static Exception UnknownMessagePackType(string type, Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown Message Pack type '{0}'.", type), reader);
			}
			public static Exception UnexpectedNullValue(string expected, string attributeName, string entityName, Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("A null value is deserialized instead of {0} for required attribute '{1}' in entity '{2}'.", expected, attributeName, entityName), reader);
			}
		}

		public static Dictionary<string, object> MergeDocuments(Dictionary<string, object> left, Dictionary<string, object> right)
		{
			if (left == null && right == null)
			{
				return null;
			}
			else if (left == null)
			{
				return right;
			}
			else if (right == null)
			{
				return left;
			}

			var keys = new HashSet<string>(left.Keys.Concat(right.Keys));
			var result = new Dictionary<string, object>(keys.Count);
			foreach (var key in keys)
			{
				var leftValue = default(object);
				var rightValue = default(object);
				var leftHasValue = left.TryGetValue(key, out leftValue);
				var rightHasValue = right.TryGetValue(key, out rightValue);
				var leftDocument = leftValue as Dictionary<string, object>;
				var rightDocument = rightValue as Dictionary<string, object>;
				var leftIsDeleted = leftHasValue && leftValue == null;
				var rightIsDeleted = rightHasValue && rightValue == null;

				if (!leftHasValue && !rightHasValue)
				{
					continue;
				}
				if ((leftIsDeleted || rightIsDeleted) && (leftDocument != null || rightDocument != null))
				{
					result[key] = null; // keep deleted documents as deleted
				}
				else if (!rightHasValue)
				{
					result[key] = leftValue;
				}
				else if (!leftHasValue)
				{
					result[key] = rightValue;
				}
				else if (leftDocument != null && rightDocument != null)
				{
					result[key] = MergeDocuments(leftDocument, rightDocument);
				}
				else
				{
					result[key] = rightValue;
				}
			}
			return result;
		}

		#region EndianBitConverter by Jon Skeet and Marc Gravell
		/* "Miscellaneous Utility Library" Software Licence

		Version 1.0

		Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
		All rights reserved.

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions
		are met:

		1. Redistributions of source code must retain the above copyright
		notice, this list of conditions and the following disclaimer.

		2. Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.

		3. The end-user documentation included with the redistribution, if
		any, must include the following acknowledgment:

		"This product includes software developed by Jon Skeet
		and Marc Gravell. Contact skeet@pobox.com, or see
		http://www.pobox.com/~skeet/)."

		Alternately, this acknowledgment may appear in the software itself,
		if and wherever such third-party acknowledgments normally appear.

		4. The name "Miscellaneous Utility Library" must not be used to endorse
		or promote products derived from this software without prior written
		permission. For written permission, please contact skeet@pobox.com.

		5. Products derived from this software may not be called
		"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
		appear in their name, without prior written permission of Jon Skeet.

		THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
		WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
		MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
		IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
		INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
		BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
		CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
		LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
		ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
		POSSIBILITY OF SUCH DAMAGE.
		*/

		internal enum Endianness
		{
			LittleEndian,

			BigEndian
		}

		private abstract class EndianBitConverter
		{
			#region Endianness of this converter

			public abstract bool IsLittleEndian();

			public abstract Endianness Endianness { get; }

			#endregion

			#region Factory properties

			private static readonly LittleEndianBitConverter little = new LittleEndianBitConverter();

			public static LittleEndianBitConverter Little
			{
				get { return little; }
			}

			private static readonly BigEndianBitConverter big = new BigEndianBitConverter();

			public static BigEndianBitConverter Big
			{
				get { return big; }
			}

			#endregion

			#region Double/primitive conversions

			public long DoubleToInt64Bits(double value)
			{
				return BitConverter.DoubleToInt64Bits(value);
			}

			public double Int64BitsToDouble(long value)
			{
				return BitConverter.Int64BitsToDouble(value);
			}

			public int SingleToInt32Bits(float value)
			{
				return new Int32SingleUnion(value).AsInt32;
			}

			public float Int32BitsToSingle(int value)
			{
				return new Int32SingleUnion(value).AsSingle;
			}

			#endregion

			#region To(PrimitiveType) conversions

			public bool ToBoolean(byte[] value, int startIndex)
			{
				CheckByteArgument(value, startIndex, 1);
				return BitConverter.ToBoolean(value, startIndex);
			}

			public char ToChar(byte[] value, int startIndex)
			{
				return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
			}

			public double ToDouble(byte[] value, int startIndex)
			{
				return Int64BitsToDouble(ToInt64(value, startIndex));
			}

			public float ToSingle(byte[] value, int startIndex)
			{
				return Int32BitsToSingle(ToInt32(value, startIndex));
			}

			public short ToInt16(byte[] value, int startIndex)
			{
				return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
			}

			public int ToInt32(byte[] value, int startIndex)
			{
				return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
			}

			public long ToInt64(byte[] value, int startIndex)
			{
				return CheckedFromBytes(value, startIndex, 8);
			}

			public ushort ToUInt16(byte[] value, int startIndex)
			{
				return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
			}

			public uint ToUInt32(byte[] value, int startIndex)
			{
				return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
			}

			public ulong ToUInt64(byte[] value, int startIndex)
			{
				return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
			}

			private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (startIndex < 0 || startIndex > value.Length - bytesRequired)
				{
					throw new ArgumentOutOfRangeException("startIndex");
				}
			}

			private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
			{
				CheckByteArgument(value, startIndex, bytesToConvert);
				return FromBytes(value, startIndex, bytesToConvert);
			}

			protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

			#endregion

			#region ToString conversions

			public static string ToString(byte[] value)
			{
				return BitConverter.ToString(value);
			}

			public static string ToString(byte[] value, int startIndex)
			{
				return BitConverter.ToString(value, startIndex);
			}

			public static string ToString(byte[] value, int startIndex, int length)
			{
				return BitConverter.ToString(value, startIndex, length);
			}

			#endregion

			#region	Decimal conversions

			public decimal ToDecimal(byte[] value, int startIndex)
			{
				// HACK: This always assumes four parts, each in their own endianness,
				// starting with the first part at the start of the byte array.
				// On the other hand, there's no real format specified...
				var parts = new int[4];
				for (var i = 0; i < 4; i++)
				{
					parts[i] = ToInt32(value, startIndex + i * 4);
				}
				return new decimal(parts);
			}

			public byte[] GetBytes(decimal value)
			{
				var bytes = new byte[16];
				var parts = decimal.GetBits(value);
				for (var i = 0; i < 4; i++)
				{
					CopyBytesImpl(parts[i], 4, bytes, i * 4);
				}
				return bytes;
			}

			public void CopyBytes(decimal value, byte[] buffer, int index)
			{
				var parts = decimal.GetBits(value);
				for (var i = 0; i < 4; i++)
				{
					CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
				}
			}

			#endregion

			#region GetBytes conversions

			private byte[] GetBytes(long value, int bytes)
			{
				var buffer = new byte[bytes];
				CopyBytes(value, bytes, buffer, 0);
				return buffer;
			}

			public byte[] GetBytes(bool value)
			{
				return BitConverter.GetBytes(value);
			}

			public byte[] GetBytes(char value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(double value)
			{
				return GetBytes(DoubleToInt64Bits(value), 8);
			}

			public byte[] GetBytes(short value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(int value)
			{
				return GetBytes(value, 4);
			}

			public byte[] GetBytes(long value)
			{
				return GetBytes(value, 8);
			}

			public byte[] GetBytes(float value)
			{
				return GetBytes(SingleToInt32Bits(value), 4);
			}

			public byte[] GetBytes(ushort value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(uint value)
			{
				return GetBytes(value, 4);
			}

			public byte[] GetBytes(ulong value)
			{
				return GetBytes(unchecked((long)value), 8);
			}

			#endregion

			#region CopyBytes conversions

			private void CopyBytes(long value, int bytes, byte[] buffer, int index)
			{
				if (buffer == null)
				{
					throw new ArgumentNullException("buffer", "Byte array must not be null");
				}
				if (buffer.Length < index + bytes)
				{
					throw new ArgumentOutOfRangeException("Buffer not big enough for value");
				}
				CopyBytesImpl(value, bytes, buffer, index);
			}

			protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

			public void CopyBytes(bool value, byte[] buffer, int index)
			{
				CopyBytes(value ? 1 : 0, 1, buffer, index);
			}

			public void CopyBytes(char value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(double value, byte[] buffer, int index)
			{
				CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
			}

			public void CopyBytes(short value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(int value, byte[] buffer, int index)
			{
				CopyBytes(value, 4, buffer, index);
			}

			public void CopyBytes(long value, byte[] buffer, int index)
			{
				CopyBytes(value, 8, buffer, index);
			}

			public void CopyBytes(float value, byte[] buffer, int index)
			{
				CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
			}

			public void CopyBytes(ushort value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(uint value, byte[] buffer, int index)
			{
				CopyBytes(value, 4, buffer, index);
			}

			public void CopyBytes(ulong value, byte[] buffer, int index)
			{
				CopyBytes(unchecked((long)value), 8, buffer, index);
			}

			#endregion

			#region Private struct used for Single/Int32 conversions

			[StructLayout(LayoutKind.Explicit)]
			private struct Int32SingleUnion
			{
				[FieldOffset(0)]
				private readonly int i;

				[FieldOffset(0)]
				private readonly float f;

				internal Int32SingleUnion(int i)
				{
					this.f = 0; // Just to keep the compiler happy
					this.i = i;
				}

				internal Int32SingleUnion(float f)
				{
					this.i = 0; // Just to keep the compiler happy
					this.f = f;
				}

				internal int AsInt32
				{
					get { return i; }
				}

				internal float AsSingle
				{
					get { return f; }
				}
			}

			#endregion
		}

		private sealed class BigEndianBitConverter : EndianBitConverter
		{
			public sealed override bool IsLittleEndian()
			{
				return false;
			}

			public sealed override Endianness Endianness
			{
				get { return Endianness.BigEndian; }
			}

			protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
			{
				var endOffset = index + bytes - 1;
				for (var i = 0; i < bytes; i++)
				{
					buffer[endOffset - i] = unchecked((byte)(value & 0xff));
					value = value >> 8;
				}
			}

			protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
			{
				long ret = 0;
				for (var i = 0; i < bytesToConvert; i++)
				{
					ret = unchecked((ret << 8) | buffer[startIndex + i]);
				}
				return ret;
			}
		}

		private sealed class LittleEndianBitConverter : EndianBitConverter
		{
			public sealed override bool IsLittleEndian()
			{
				return true;
			}

			public sealed override Endianness Endianness
			{
				get { return Endianness.LittleEndian; }
			}

			protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
			{
				for (var i = 0; i < bytes; i++)
				{
					buffer[i + index] = unchecked((byte)(value & 0xff));
					value = value >> 8;
				}
			}

			protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
			{
				long ret = 0;
				for (var i = 0; i < bytesToConvert; i++)
				{
					ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
				}
				return ret;
			}
		}

		/* end of Jon Skeet and Marc Gravell code */
		#endregion

		#endregion

		#region Serialization: JSON
		private void ReadJson(GameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using(var patchJsonReader = new JsonReader(new StreamReader(patchStream, encoding), leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchJsonReader.ReadDocument());
					}
				}
			}

			using(var jsonReader = new JsonReader(new StreamReader(data, encoding), leaveOpen))
			{
				jsonReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private sealed partial class JsonReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
			private const int CHAR_SIZE = 2;

			const int LEXER_STATE_COMPLETE = -1;
			const int LEXER_STATE_START = 0;
			const int LEXER_STATE_LEXEME = 1;
			const int LEXER_STATE_QUOTED = 2;
			const int LEXER_STATE_QUOTED_ESCAPE = 3;
			const int LEXER_STATE_COMMENT_BEGINING = 4;
			const int LEXER_STATE_COMMENT_SINGLELINE = 5;
			const int LEXER_STATE_COMMENT_MULTILINE = 6;
			const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

			private const int NUMBER_FLOAT = 2;
			private const int NUMBER_FLOAT_WITH_EXP = 3;
			private const int NUMBER_INTEGER = 0;
			private const int NUMBER_NEGATIVE_INTEGER = 1;
			private const int NUMBER_NOT = -1;

			private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
			private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

			private readonly ArraySegment<char> LexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
			private readonly ArraySegment<char> LexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
			private readonly ArraySegment<char> LexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

			private readonly bool leaveOpen;
			private readonly TextReader textReader;

			// tokenizing
			private readonly char[] buffer;
			private int bufferOffset;
			private int bufferAvailable;
			private int lineNum = 1;
			private int colNum = 1;

			// parsing
			private ReaderNode node;
			private ArraySegment<char> rawJson;

			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;
			private StrongBox<int> intBox;
			private StrongBox<DateTime> dateBox;
			private JsonValueBox jsonValueBox;

			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			// statistics
			public override int LineNumber { get { return this.lineNum; } }
			public override int ColumnNumber { get { return this.colNum; } }

			public JsonReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (textReader == null) throw new ArgumentNullException("textReader");
				if (bufferSize <= 0) throw new ArgumentOutOfRangeException("bufferSize");

				this.buffer = new char[bufferSize];
				this.textReader = textReader;
				this.leaveOpen = leaveOpen;
			}

			public override bool NextToken()
			{
				this.rawJson = default(ArraySegment<char>);
				this.node = default(ReaderNode);

				var fragments = default(ArraySegment<char>[]);
				var state = LEXER_STATE_COMPLETE;
				var lexemeSize = 0;

				var lexeme = this.NextLexeme(ref state);
				if (lexeme.Count == 0)
				{
					this.node = new ReaderNode(ReaderToken.EndOfStream);
					return false;
				}
				if (state != LEXER_STATE_COMPLETE)
				{
					var firstFragment = Copy(ref lexeme);
					var secondFragment = this.NextLexeme(ref state);

					if (state == LEXER_STATE_COMPLETE)
					{
						if (secondFragment.Count == 0)
						{
							lexeme = firstFragment;
							lexemeSize = lexeme.Count;
						}
						else
						{
							fragments = new ArraySegment<char>[2] { firstFragment, secondFragment };
							lexemeSize = firstFragment.Count + secondFragment.Count;
						}
					}
					else
					{
						var fragmentIndex = 0;
						fragments = new ArraySegment<char>[8];
						fragments[fragmentIndex++] = firstFragment;
						fragments[fragmentIndex++] = Copy(ref secondFragment);
						lexemeSize = firstFragment.Count + secondFragment.Count;

						do
						{
							lexeme = this.NextLexeme(ref state);

							if (lexeme.Count == 0)
							{
								break;
							}
							if (fragmentIndex == fragments.Length)
							{
								Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
							}

							fragments[fragmentIndex++] = Copy(ref lexeme);
							lexemeSize += lexeme.Count;

						} while (state != LEXER_STATE_COMPLETE);
					}
				}
				else
				{
					lexemeSize = lexeme.Count;
				}

				if (lexemeSize == 1)
				{
					this.rawJson = fragments != null ? fragments[0] : lexeme;
					switch (rawJson.Array[rawJson.Offset])
					{
						case JsonNotation.Const0: this.node = new ReaderNode(ReaderToken.Value, this.Box(0)); return true;
						case JsonNotation.Const1: this.node = new ReaderNode(ReaderToken.Value, this.Box(1)); return true;
						case JsonNotation.Const2: this.node = new ReaderNode(ReaderToken.Value, this.Box(2)); return true;
						case JsonNotation.Const3: this.node = new ReaderNode(ReaderToken.Value, this.Box(3)); return true;
						case JsonNotation.Const4: this.node = new ReaderNode(ReaderToken.Value, this.Box(4)); return true;
						case JsonNotation.Const5: this.node = new ReaderNode(ReaderToken.Value, this.Box(5)); return true;
						case JsonNotation.Const6: this.node = new ReaderNode(ReaderToken.Value, this.Box(6)); return true;
						case JsonNotation.Const7: this.node = new ReaderNode(ReaderToken.Value, this.Box(7)); return true;
						case JsonNotation.Const8: this.node = new ReaderNode(ReaderToken.Value, this.Box(8)); return true;
						case JsonNotation.Const9: this.node = new ReaderNode(ReaderToken.Value, this.Box(9)); return true;
						case JsonNotation.BeginArray: this.node = new ReaderNode(ReaderToken.BeginArray); return true;
						case JsonNotation.BeginObject: this.node = new ReaderNode(ReaderToken.BeginObject); return true;
						case JsonNotation.EndArray: this.node = new ReaderNode(ReaderToken.EndOfArray); return true;
						case JsonNotation.EndObject: this.node = new ReaderNode(ReaderToken.EndOfObject); return true;
						default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
					}
				}
				if (lexemeSize == 4)
				{
					if (Match(ref lexeme, fragments, 0, LexemeTrue))
					{
						this.rawJson = LexemeTrue;
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						return true;
					}
					if (Match(ref lexeme, fragments, 0, LexemeNull))
					{
						this.rawJson = LexemeNull;
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					}
				}
				if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, LexemeFalse))
				{
					this.rawJson = LexemeFalse;
					this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
					return true;
				}

				// combine fragments into one lexeme
				if (fragments != null)
				{
					var combined = new char[lexemeSize];
					var offset = 0;
					foreach (var fragment in fragments)
					{
						if (fragment.Array == null) break;
						Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
						offset += fragment.Count;
					}
					lexeme = new ArraySegment<char>(combined, 0, offset);
					//fragments = null;
				}

				this.rawJson = lexeme;
				if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
				{
					if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
						throw ReaderException.UnterminatedStringLiteral(this);

					if (lexemeSize == 2)
					{
						this.node = new ReaderNode(ReaderToken.Value, string.Empty);
						return true;
					}
					{
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme));
					}
					return true;
				}

				switch (GetNumberType(ref lexeme))
				{
					case NUMBER_INTEGER:
						var integerType = lexeme.Count < Int32MaxLength
							? typeof(int)
							: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, integerType));
						return true;
					case NUMBER_NEGATIVE_INTEGER:
						var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, signedIntegerType));
						return true;
					case NUMBER_FLOAT:
					case NUMBER_FLOAT_WITH_EXP:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, typeof(double)));
						return true;
					default:
						throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}

			private object Box(ref ArraySegment<char> lexeme)
			{
				if (this.jsonValueBox == null)
					this.jsonValueBox = new JsonValueBox(FormatProvider);

				this.jsonValueBox.Store(lexeme, typeof(string));

				return this.jsonValueBox;
			}
			private object Box(ref ArraySegment<char> lexeme, Type type)
			{
				if (type == null) throw new ArgumentNullException("type");

				if (this.jsonValueBox == null)
					this.jsonValueBox = new JsonValueBox(FormatProvider);

				this.jsonValueBox.Store(lexeme, type);
				return this.jsonValueBox;
			}
			private object Box(int value)
			{
				if (this.intBox == null)
					this.intBox = new StrongBox<int>(FormatProvider);

				this.intBox.Store(value);
				return this.intBox;
			}
			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);

				return this.intBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				if (this.falseBox == null)
					this.falseBox = new StrongBox<bool>(false, FormatProvider);
				return falseBox;
			}

			private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
			{
				var count = matchTo.Count;
				if (fragments == null)
				{
					for (int i = 0; i < count; i++)
					{
						if (lexeme.Array[lexeme.Offset + i] != matchTo.Array[matchTo.Offset + i])
							return false;
					}

					return true;
				}
				var mo = 0;
				foreach (var fg in fragments)
				{
					if (fg.Array == null) break;

					for (int i = 0; i < fg.Count; i++)
					{
						if (fg.Array[fg.Offset + i] != matchTo.Array[mo])
							return false;

						mo++;
					}
				}

				return true;
			}
			private static int GetNumberType(ref ArraySegment<char> lexeme)
			{
				const int INT_PART = 0;
				const int FRAC_PART = 1;
				const int EXP_PART = 2;
				const char POINT = '.';
				const char EXPONENT = 'E';
				const char EXPONENT_ALT = 'e';
				const char PLUS = '+';
				const char MINUS = '-';
				const char DIGIT_START = '0';
				const char DIGIT_END = '9';

				var isNegative = false;
				var buffer = lexeme.Array;
				var offset = lexeme.Offset;
				var count = lexeme.Offset + lexeme.Count;

				var part = INT_PART;

				for (var i = offset; i < count; i++)
				{
					var character = buffer[i];

					switch (part)
					{
						case INT_PART:
							switch (character)
							{
								case MINUS:
									if (i != offset)
									{
										return NUMBER_NOT;
									}
									isNegative = true;
									break;
								case PLUS:
									if (i != offset)
									{
										return NUMBER_NOT;
									}
									break;
								case POINT:
									if (i == offset)
									{
										return NUMBER_NOT; // decimal point as first character
									}
									part = FRAC_PART;
									break;
								default:
									if (character == EXPONENT || character == EXPONENT_ALT)
									{
										if (i == offset)
										{
											return NUMBER_NOT; // exponent at first character
										}
										part = EXP_PART;
									}
									else if (character < DIGIT_START && character > DIGIT_END)
									{
										return NUMBER_NOT; // non digit character in integer part
									}
									break;
							}
							break;
						case FRAC_PART:
							if (character == EXPONENT || character == EXPONENT_ALT)
							{
								if (i == offset)
								{
									return NUMBER_NOT; // exponent at first character
								}
								part = EXP_PART;
							}
							else if (character < DIGIT_START && character > DIGIT_END)
							{
								return NUMBER_NOT; // non digit character in fraction part
							}
							break;
						case EXP_PART:
							if (character == PLUS || character == MINUS)
							{
								if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
								{
									return NUMBER_NOT; // sign not at start of exponent part
								}
							}
							else if (character < DIGIT_START && character > DIGIT_END)
							{
								return NUMBER_NOT; // non digit character in integer part
							}
							break;
					}
				}

				switch (part)
				{
					case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
					case FRAC_PART: return NUMBER_FLOAT;
					case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
					default: return NUMBER_NOT;
				}
			}
			private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
			{
				var newLexeme = new ArraySegment<char>(new char[lexeme.Count], 0, lexeme.Count);
				Buffer.BlockCopy(lexeme.Array, lexeme.Offset * CHAR_SIZE, newLexeme.Array, 0, lexeme.Count * CHAR_SIZE);
				return newLexeme;
			}
			private static bool IsWhiteSpaceLatin(char character)
			{
				return character == ' ' || character >= '\t' && character <= '\r' || (character == ' ' || character == '\x0085');
			}
			private ArraySegment<char> NextLexeme(ref int state)
			{
				this.ResetBufferIfNeeded();

				var buffer = this.buffer;
				var lexemeStartIndex = this.bufferOffset;
				var lexemeLength = 0;

				start:
				if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
				{
					state = LEXER_STATE_COMPLETE;
					return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
				}

				if (state == LEXER_STATE_COMPLETE)
					state = LEXER_STATE_START;

				var bufferEnd = this.bufferOffset + this.bufferAvailable;
				for (var i = this.bufferOffset; i < bufferEnd; i++)
				{
					this.colNum++;
					switch (state)
					{
						case LEXER_STATE_START:
							switch (buffer[i])
							{
								case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
								case JsonNotation.Space:
								case JsonNotation.Return:
								case JsonNotation.Tab:
								case JsonNotation.IdentifierSeparator:
								case JsonNotation.ValueSeparator:
									continue; // insignificant whitespaces
								case JsonNotation.Comment:
									state = LEXER_STATE_COMMENT_BEGINING;
									continue;
								case JsonNotation.EndArray:
								case JsonNotation.EndObject:
								case JsonNotation.BeginObject:
								case JsonNotation.BeginArray:
									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i + 1;
									this.bufferAvailable = bufferEnd - i - 1;
									return new ArraySegment<char>(buffer, i, 1);
								case JsonNotation.Quote:
									lexemeStartIndex = i;
									state = LEXER_STATE_QUOTED;
									continue;
								default:
									if (IsWhiteSpaceLatin(buffer[i]))
									{
										goto case JsonNotation.Space;
									}
									lexemeStartIndex = i;
									state = LEXER_STATE_LEXEME;
									continue;
							}
						case LEXER_STATE_LEXEME:
							switch (buffer[i])
							{
								// lexeme terminators
								case JsonNotation.Space:
								case JsonNotation.Newline:
								case JsonNotation.Return:
								case JsonNotation.Tab:
								case JsonNotation.IdentifierSeparator:
								case JsonNotation.ValueSeparator:
								case JsonNotation.EndArray:
								case JsonNotation.EndObject:
								case JsonNotation.BeginObject:
								case JsonNotation.BeginArray:
									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i;
									this.bufferAvailable = bufferEnd - i;
									return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
								default:
									if (IsWhiteSpaceLatin(buffer[i]))
									{
										goto case JsonNotation.Space;
									}
									continue;
							}
						case LEXER_STATE_QUOTED:
						case LEXER_STATE_QUOTED_ESCAPE:
							switch (buffer[i])
							{
								case JsonNotation.Newline:
								case JsonNotation.Return:
									throw ReaderException.UnterminatedStringLiteral(this);
								case JsonNotation.Quote:
									if (state == LEXER_STATE_QUOTED_ESCAPE)
									{
										state = LEXER_STATE_QUOTED;
										continue;
									}

									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i + 1;
									this.bufferAvailable = bufferEnd - i - 1;
									return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
								case JsonNotation.Escape:
									state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
									continue;
								default:
									if (state == LEXER_STATE_QUOTED_ESCAPE)
									{
										state = LEXER_STATE_QUOTED;
									}
									continue;
							}
						case LEXER_STATE_COMMENT_BEGINING:
							switch (buffer[i])
							{
								case JsonNotation.Comment:
									state = LEXER_STATE_COMMENT_SINGLELINE;
									continue;
								case JsonNotation.CommentMultiline:
									state = LEXER_STATE_COMMENT_MULTILINE;
									continue;
								default:
									throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
							}
						case LEXER_STATE_COMMENT_SINGLELINE:
							switch (buffer[i])
							{
								case JsonNotation.Newline:
								case JsonNotation.Return:
									state = LEXER_STATE_START;
									continue;
								default: continue;
							}
						case LEXER_STATE_COMMENT_MULTILINE_ENDING:
						case LEXER_STATE_COMMENT_MULTILINE:
							switch (buffer[i])
							{
								case JsonNotation.CommentMultiline:
									state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
									continue;
								case JsonNotation.Comment:
									if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
										state = LEXER_STATE_START;
									continue;
								default: continue;
							}

					}
				}

				if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINING || state == LEXER_STATE_COMMENT_MULTILINE || 
					state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLELINE)
				{
					// no lexemes found in current buffer
					this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
					goto start; // restart
				}

				lexemeLength = bufferEnd - lexemeStartIndex;
			
				// buffer contains only fragment of lexeme
				// lexeme parsing is not complete so there is 2 options:
				// 1) try to fill buffer and retry parsing
				// 2) return fragment to caller

				if (lexemeLength < this.buffer.Length / 2)
				{
					// if fragment is small then move fragment to the start of the buffer and re-start parsing
					if (lexemeStartIndex != 0)
					{
						Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
						lexemeStartIndex = 0;
					}

					this.bufferOffset = lexemeLength;
					this.bufferAvailable = 0;

					goto start; // restart
				}
				else
				{
					// if fragment is huge then return it to caller

					// set buffer is consumed
					this.bufferOffset = this.bufferAvailable = 0;

					return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
				}
			}
			private void ResetBufferIfNeeded()
			{
				if (this.bufferAvailable == 0)
				{
					this.bufferOffset = 0;
				}
			}
			private int ReadToBuffer()
			{
				if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
				{
					throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
				}

				var offset = this.bufferOffset + this.bufferAvailable;
				var count = this.buffer.Length - offset;
				var read = this.textReader.Read(this.buffer, offset, count);
				this.bufferAvailable += read;
				return read;
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.textReader.Dispose();
			}

			private sealed class JsonValueBox : IStrongBox
			{
				private readonly IFormatProvider formatProvider;
				private ArraySegment<char> value;
				private Type valueType;

				public Type ValueType { get { return this.valueType; } }

				public bool AsBoolean { get { return Convert.ToBoolean(this.LoadString(), FormatProvider); } }
				public byte AsByte { get { return checked((byte)this.LoadUInt32()); } }
				public short AsInt16 { get { return checked((short)this.LoadInt32()); } }
				public int AsInt32 { get { return this.LoadInt32(); } }
				public long AsInt64 { get { return this.LoadInt64(); } }
				public sbyte AsSByte { get { return checked((sbyte)this.LoadInt32()); } }
				public ushort AsUInt16 { get { return checked((ushort)this.LoadUInt32()); } }
				public uint AsUInt32 { get { return this.LoadUInt32(); } }
				public ulong AsUInt64 { get { return this.LoadUInt64(); } }
				public float AsSingle { get { return Convert.ToSingle(this.LoadString(), FormatProvider); } }
				public double AsDouble { get { return Convert.ToDouble(this.LoadString(), FormatProvider); } }
				public decimal AsDecimal { get { return Convert.ToDecimal(this.LoadString(), FormatProvider); } }
				public object AsObject { get { return this.LoadString(); } }

				public JsonValueBox(IFormatProvider formatProvider)
				{
					if (formatProvider == null) throw new ArgumentNullException("formatProvider");

					this.formatProvider = formatProvider;
				}

				private uint LoadUInt32()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToUInt32(array, offset, count, this.formatProvider);
				}
				private ulong LoadUInt64()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToUInt64(array, offset, count, this.formatProvider);
				}
				private int LoadInt32()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToInt32(array, offset, count, this.formatProvider);
				}
				private long LoadInt64()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToInt64(array, offset, count, this.formatProvider);
				}
				private string LoadString()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.UnEscapeBuffer(array, offset, count, false);
				}

				public void Store<T>(T value)
				{
					this.value = (ArraySegment<char>)(object)value;
					this.valueType = typeof(string);
				}

				public void Store(ArraySegment<char> value, Type valueType)
				{
					if (valueType == null) throw new ArgumentNullException("valueType");

					this.value = value;
					this.valueType = valueType;
				}

				public override string ToString()
				{
					return this.LoadString();
				}
			}

			private static class JsonUtils
			{
				public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
				{
					if (charsToUnEscape == null) throw new ArgumentNullException("charsToUnEscape");
					if (offset < 0) throw new ArgumentOutOfRangeException("offset");
					if (count < 0) throw new ArgumentOutOfRangeException("count");
					if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException("offset");

					var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
					if (unEscapedCount == count)
					{
						return new string(charsToUnEscape, offset, count);
					}

					var resultBuilder = new StringBuilder(unEscapedCount);
					var plainStart = offset;
					var plainLen = 0;
					var end = offset + count;
					for (var i = offset; i < end; i++)
					{
						var ch = charsToUnEscape[i];
						if (ch != '\\')
						{
							plainLen++;
							continue;
						}

						if (i + 1 >= end)
						{
							if (strict)
							{
								throw ReaderException.UnknownEscapeSequence("\\\0", null);
							}
							else
							{
								plainLen++;
								break; // u
							}
						}

						var sequenceLength = 1;
						// append unencoded chunk
						if (plainLen != 0)
						{
							resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
							plainLen = 0;
						}

						var sequenceKind = charsToUnEscape[i + 1];
						switch (sequenceKind)
						{
							case 'n':
								resultBuilder.Append('\n');
								break;
							case 'r':
								resultBuilder.Append('\r');
								break;
							case 'b':
								resultBuilder.Append('\b');
								break;
							case 'f':
								resultBuilder.Append('\f');
								break;
							case 't':
								resultBuilder.Append('\t');
								break;
							case '\\':
								resultBuilder.Append('\\');
								break;
							case '/':
								resultBuilder.Append('/');
								break;
							case '\'':
								resultBuilder.Append('\'');
								break;
							case '\"':
								resultBuilder.Append('\"');
								break;

							// unicode symbol
							case 'u':
								resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
								sequenceLength = 5;
								break;

							// latin hex encoded symbol
							case 'x':
								resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
								sequenceLength = 3;
								break;

							// latin dec encoded symbol
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
							case '0':
								resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
								sequenceLength = 3;
								break;
							default:
								if (!strict)
								{
									resultBuilder.Append(sequenceKind);
									break;
								}
								else
								{
									throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
								}
						}

						// set next chunk start right after this escape
						plainStart = i + sequenceLength + 1;
						i += sequenceLength;
					}

					// append last unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
					}

					return resultBuilder.ToString();
				}
				private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
				{
					if (charsToUnEscape == null) throw new ArgumentNullException("charsToUnEscape");
					if (offset < 0) throw new ArgumentOutOfRangeException("offset");
					if (count < 0) throw new ArgumentOutOfRangeException("count");
					if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException("offset");

					var newCount = 0;
					var end = offset + count;
					for (var i = offset; i < end; i++)
					{
						var ch = charsToUnEscape[i];
						newCount++;
						if (ch != '\\')
						{
							continue;
						}

						var toSkip = 1;
						var sequenceKind = charsToUnEscape[i + 1];
						switch (sequenceKind)
						{
							// unicode symbol
							case 'u':
								toSkip = 5;
								break;

							// latin hex encoded symbol
							case 'x':
								toSkip = 3;
								break;
							// latin dec encoded symbol
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
							case '0':
								toSkip = 3;
								break;
							default:
								toSkip = 1;
								break;
						}
						i += toSkip;
					}
					return newCount;
				}

				public static uint HexStringToUInt32(char[] buffer, int offset, int count)
				{
					const uint ZERO = (ushort)'0';
					const uint a = (ushort)'a';
					const uint A = (ushort)'A';

					var result = 0u;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						var d = 0u;
						if (c >= '0' && c <= '9')
							d = (c - ZERO);
						else if (c >= 'a' && c <= 'f')
							d = 10u + (c - a);
						else if (c >= 'A' && c <= 'F')
							d = 10u + (c - A);
						else
							throw new FormatException();

						result = 16u * result + d;
					}

					return result;
				}

				public static long StringToInt64(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const ulong ZERO = (ushort)'0';

					var result = 0UL;
					var neg = false;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (i == 0 && c == '-')
						{
							neg = true;
							continue;
						}
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10UL * result + (c - ZERO));
					}

					if (neg)
						return -(long)(result);
					return (long)result;
				}
				public static int StringToInt32(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const uint ZERO = (ushort)'0';

					var result = 0u;
					var neg = false;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (i == 0 && c == '-')
						{
							neg = true;
							continue;
						}
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10u * result + (c - ZERO));
					}

					if (neg)
						return -(int)(result);
					return (int)result;
				}
				public static ulong StringToUInt64(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const ulong ZERO = (ushort)'0';

					var result = 0UL;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10UL * result + (c - ZERO));
					}

					return result;
				}
				public static uint StringToUInt32(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const uint ZERO = (ushort)'0';

					var result = 0U;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10 * result + (c - ZERO));
					}

					return result;
				}
			}

			private static class JsonNotation
			{
				public const char Tab = '\t';
				public const char Space = ' ';
				public const char Newline = '\n';
				public const char Return = '\r';
				public const char IdentifierSeparator = ':';
				public const char ValueSeparator = ',';
				public const char BeginArray = '[';
				public const char EndArray = ']';
				public const char BeginObject = '{';
				public const char EndObject = '}';
				public const char Escape = '\\';
				public const char Comment = '/';
				public const char CommentMultiline = '*';
				public const char Quote = '\"';
				public const char Const0 = '0';
				public const char Const1 = '1';
				public const char Const2 = '2';
				public const char Const3 = '3';
				public const char Const4 = '4';
				public const char Const5 = '5';
				public const char Const6 = '6';
				public const char Const7 = '7';
				public const char Const8 = '8';
				public const char Const9 = '9';
				public const string True = "true";
				public const string False = "false";
				public const string Null = "null";
			}
		}
		#endregion

		#region Serialization: Message Pack
		private void ReadMessagePack(GameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using(var patchMsgPackReader = new MessagePackReader(patchStream, leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchMsgPackReader.ReadDocument());
					}
				}
			}

			using (var msgPackReader = new MessagePackReader(data, leaveOpen))
			{
				msgPackReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private sealed class MessagePackReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
			private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
			private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

			internal struct Map
			{
				public ReaderToken Token;
				public long Counter;
			}

			private readonly Stream inputStream;
			private readonly bool leaveOpen;
			private readonly byte[] buffer;
			private readonly EndianBitConverter bitConverter;
			private readonly Stack<Map> maps;
			private ReaderNode node;
			private int bufferOffset;
			private int bufferReaded;
			private int bufferAvailable;
			private int totalBytesReaded;

			private StrongBox<int> int32Box;
			private StrongBox<uint> uInt32Box;
			private StrongBox<long> int64Box;
			private StrongBox<ulong> uInt64Box;
			private StrongBox<float> singleBox;
			private StrongBox<double> doubleBox;
			private StrongBox<decimal> decimalBox;
			private StrongBox<DateTime> dateBox;
			private StrongBox<DateTimeOffset> dateOffsetBox;
			private StrongBox<TimeSpan> timeSpanBox;
			private StrongBox<Guid> guidBox;
			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;

			public override int LineNumber { get { return 0; } }
			public override int ColumnNumber { get { return this.totalBytesReaded; } }
			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			public MessagePackReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (stream == null) throw new ArgumentNullException("stream");

				if (bufferSize < DEFAULT_BUFFER_SIZE)
					bufferSize = DEFAULT_BUFFER_SIZE;

				this.inputStream = stream;
				this.leaveOpen = leaveOpen;
				this.buffer = new byte[bufferSize];
				this.bufferOffset = 0;
				this.bufferReaded = 0;
				this.bufferAvailable = 0;
				this.bitConverter = EndianBitConverter.Big;
				this.maps = new Stack<Map>();
			}

			public override bool NextToken()
			{
				if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
				{
					var closingToken = this.maps.Pop();
					this.node = new ReaderNode(closingToken.Token);

					this.DecrementClosingTokenCounter();
					return true;
				}

				if (!this.ReadToBuffer(1, throwOnEos: false))
				{
					this.node = new ReaderNode(ReaderToken.EndOfStream);
					return false;
				}

				var formatValue = buffer[this.bufferOffset];
				if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
				{
					var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

					this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
					this.node = new ReaderNode(ReaderToken.BeginArray);
				}
				else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
				{
					var strCount = formatValue - (byte)MessagePackType.FixStrStart;
					var strBytes = this.ReadBytes(strCount);

					var token = ReaderToken.Value;
					if (this.maps.Count > 0)
					{
						var closingToken = this.maps.Peek();
						if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
							token = ReaderToken.Member;
					}

					var strValue = default(string);

					{
						strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
					}

					this.node = new ReaderNode(token, strValue);
				}
				else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
				{
					var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
					this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
					this.node = new ReaderNode(ReaderToken.BeginObject);
				}
				else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
				{
					var value = unchecked((sbyte)formatValue);
					this.node = new ReaderNode(ReaderToken.Value, this.Box(value));
				}
				else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
				{
					var value = unchecked((byte)formatValue);
					this.node = new ReaderNode(ReaderToken.Value, this.Box(value));
				}
				else
				{
					switch ((MessagePackType)formatValue)
					{
						case MessagePackType.Nil:
							this.node = new ReaderNode(ReaderToken.Null);
							break;
						case MessagePackType.Array16:
						case MessagePackType.Array32:
							var arrayCount = 0L;
							if (formatValue == (int)MessagePackType.Array16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								arrayCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Array32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								arrayCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

							this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
							this.node = new ReaderNode(ReaderToken.BeginArray);
							break;
						case MessagePackType.Map16:
						case MessagePackType.Map32:
							var mapCount = 0L;
							if (formatValue == (int)MessagePackType.Map16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								mapCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Map32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								mapCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

							this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
							this.node = new ReaderNode(ReaderToken.BeginObject);
							break;
						case MessagePackType.Str16:
						case MessagePackType.Str32:
						case MessagePackType.Str8:
							var strBytesCount = 0L;
							if (formatValue == (int)MessagePackType.Str8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								strBytesCount = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Str16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								strBytesCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Str32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								strBytesCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							var token = ReaderToken.Value;
							if (this.maps.Count > 0)
							{
								var closingToken = this.maps.Peek();
								if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
									token = ReaderToken.Member;
							}

							if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);
							if (strBytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of string");

							var strBytes = this.ReadBytes(strBytesCount);
							var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
							this.node = new ReaderNode(token, stringValue);
							break;
						case MessagePackType.Bin32:
						case MessagePackType.Bin16:
						case MessagePackType.Bin8:
							var bytesCount = 0L;
							if (formatValue == (int)MessagePackType.Bin8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								bytesCount = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Bin16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								bytesCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Bin32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								bytesCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
							if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

							var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
							this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
							break;
						case MessagePackType.FixExt1:
						case MessagePackType.FixExt16:
						case MessagePackType.FixExt2:
						case MessagePackType.FixExt4:
						case MessagePackType.FixExt8:
						case MessagePackType.Ext32:
						case MessagePackType.Ext16:
						case MessagePackType.Ext8:
							var extLength = 0L;
							if (formatValue == (int)MessagePackType.FixExt1)
								extLength = 1;
							else if (formatValue == (int)MessagePackType.FixExt2)
								extLength = 2;
							else if (formatValue == (int)MessagePackType.FixExt4)
								extLength = 4;
							else if (formatValue == (int)MessagePackType.FixExt8)
								extLength = 8;
							else if (formatValue == (int)MessagePackType.FixExt16)
								extLength = 16;
							if (formatValue == (int)MessagePackType.Ext8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								extLength = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Ext16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								extLength = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Ext32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								extLength = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							this.ReadToBuffer(1, throwOnEos: true);
							var extType = buffer[this.bufferOffset];

							if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);
							if (extLength < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

							var data = this.ReadBytes(extLength, forceNewBuffer: true);
							if (!this.TryReadExtType(extType, data, out this.node))
								this.node = new ReaderNode(ReaderToken.Value, data.Array);
							break;
						case MessagePackType.False:
							this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
							break;
						case MessagePackType.True:
							this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
							break;
						case MessagePackType.Float32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToSingle(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Float64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToDouble(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int16:
							this.ReadToBuffer(2, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt16(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt32(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt64(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int8:
							this.ReadToBuffer(1, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)buffer[this.bufferOffset])));
							break;
						case MessagePackType.UInt16:
							this.ReadToBuffer(2, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)bitConverter.ToUInt16(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToUInt32(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToUInt64(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt8:
							this.ReadToBuffer(1, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)buffer[this.bufferOffset]));
							break;
						case MessagePackType.PositiveFixIntStart:
						case MessagePackType.PositiveFixIntEnd:
						case MessagePackType.FixMapStart:
						case MessagePackType.FixMapEnd:
						case MessagePackType.FixArrayStart:
						case MessagePackType.FixArrayEnd:
						case MessagePackType.FixStrStart:
						case MessagePackType.FixStrEnd:
						case MessagePackType.Unused:
						case MessagePackType.NegativeFixIntStart:
						case MessagePackType.NegativeFixIntEnd:
						default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
					}
				}

				this.DecrementClosingTokenCounter();

				return true;
			}

			private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
			{
				this.bufferAvailable -= this.bufferReaded;
				this.bufferOffset += this.bufferReaded;
				this.bufferReaded = 0;

				if (this.bufferAvailable < bytesRequired)
				{
					if (this.bufferAvailable > 0)
						Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

					this.bufferOffset = 0;
					while (this.bufferAvailable < bytesRequired)
					{
						var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
						this.bufferAvailable += read;

						if (read != 0 || this.bufferAvailable >= bytesRequired)
							continue;

						if (throwOnEos)
							throw ReaderException.UnexpectedEndOfStream(this);
						else
							return false;
					}
				}

				this.bufferReaded = bytesRequired;
				this.totalBytesReaded += bytesRequired;
				return true;
			}
			private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
			{
				if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException("bytesRequired");

				this.bufferAvailable -= this.bufferReaded;
				this.bufferOffset += this.bufferReaded;
				this.bufferReaded = 0;

				if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
				{
					var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

					this.bufferAvailable -= (int)bytesRequired;
					this.bufferOffset += (int)bytesRequired;
					this.totalBytesReaded += (int)bytesRequired;

					return bytes;
				}
				else
				{
					var bytes = new byte[bytesRequired];
					var bytesOffset = 0;
					if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
					{
						var bytesToCopy = Math.Min(bytes.Length - bytesOffset, this.bufferAvailable);
						Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

						bytesOffset += bytesToCopy;
						this.bufferOffset += bytesToCopy;

						this.bufferAvailable -= bytesToCopy;
						this.totalBytesReaded += bytesToCopy;
					}

					if (this.bufferAvailable == 0)
						this.bufferOffset = 0;

					while (bytesOffset < bytes.Length)
					{
						var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

						bytesOffset += read;
						this.totalBytesReaded += read;

						if (read == 0 && bytesOffset < bytes.Length)
							throw ReaderException.UnexpectedEndOfStream(this);
					}

					return new ArraySegment<byte>(bytes, 0, bytes.Length);
				}
			}
			private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
			{
				const byte EXTENSION_TYPE_TIMESTAMP = 255;
				const byte EXTENSION_TYPE_DATE_TIME = 40;
				const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
				const byte EXTENSION_TYPE_DECIMAL = 42;
				const byte EXTENSION_TYPE_GUID = 43;
				const byte GUID_SIZE = 16;
				const byte DECIMAL_SIZE = 16;
				const byte DATE_TIME_SIZE = 16;
				const byte DATE_TIME_OFFSET_SIZE = 16;

				node = default(ReaderNode);
				switch (extType)
				{
					case EXTENSION_TYPE_TIMESTAMP:
						unchecked
						{
							var seconds = 0L;
							var nanoSeconds = 0u;
							switch (data.Count)
							{
								case 4:
									seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
									break;
								case 8:
									var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
									seconds = (int) (data64 & 0x00000003ffffffffL);
									nanoSeconds = (uint) (data64 >> 34 & uint.MaxValue);
									break;
								case 12:
									nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
									seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
									break;
								default:
									return false;
							}
							node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
							return true;
						}
					case EXTENSION_TYPE_DATE_TIME:
						if (data.Count != DATE_TIME_SIZE)
							return false;
							var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
							node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
						return true;
					case EXTENSION_TYPE_DATE_TIME_OFFSET:
						if (data.Count != DATE_TIME_OFFSET_SIZE)
							return false;
						var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
						var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
						var dateTimeOffset = new DateTimeOffset(ticks, offset);
						node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
						return true;
					case EXTENSION_TYPE_DECIMAL:
						if (data.Count != DECIMAL_SIZE)
							return false;
						var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
						node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
						return true;
					case EXTENSION_TYPE_GUID:
						if (data.Count != GUID_SIZE)
							return false;

						var buffer = data.Array;
						unchecked
						{
							var guidValue = new Guid
							(
									(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
									(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
									(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
									buffer[data.Offset + 8],
									buffer[data.Offset + 9],
									buffer[data.Offset + 10],
									buffer[data.Offset + 11],
									buffer[data.Offset + 12],
									buffer[data.Offset + 13],
									buffer[data.Offset + 14],
									buffer[data.Offset + 15]
							);

							node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
							return true;
						}
					default:
						return false;
				}
			}

			private object Box(int value)
			{
				if (this.int32Box == null)
					this.int32Box = new StrongBox<int>(FormatProvider);

				this.int32Box.Store(value);

				return this.int32Box;
			}
			private object Box(uint value)
			{
				if (this.uInt32Box == null)
					this.uInt32Box = new StrongBox<uint>(FormatProvider);

				this.uInt32Box.Store(value);

				return this.uInt32Box;
			}
			private object Box(long value)
			{
				if (this.int64Box == null)
					this.int64Box = new StrongBox<long>(FormatProvider);

				this.int64Box.Store(value);

				return this.int64Box;
			}
			private object Box(ulong value)
			{
				if (this.uInt64Box == null)
					this.uInt64Box = new StrongBox<ulong>(FormatProvider);

				this.uInt64Box.Store(value);

				return this.uInt64Box;
			}
			private object Box(float value)
			{
				if (this.singleBox == null)
					this.singleBox = new StrongBox<float>(FormatProvider);

				this.singleBox.Store(value);

				return this.singleBox;
			}
			private object Box(double value)
			{
				if (this.doubleBox == null)
					this.doubleBox = new StrongBox<double>(FormatProvider);

				this.doubleBox.Store(value);

				return this.doubleBox;
			}
			private object Box(decimal value)
			{
				if (this.decimalBox == null)
					this.decimalBox = new StrongBox<decimal>(FormatProvider);

				this.decimalBox.Store(value);

				return this.decimalBox;
			}
			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);
				return this.dateBox;
			}
			private object Box(DateTimeOffset value)
			{
				if (this.dateOffsetBox == null)
					this.dateOffsetBox = new StrongBox<DateTimeOffset>(FormatProvider);

				this.dateOffsetBox.Store(value);
				return this.dateOffsetBox;
			}
			private object Box(TimeSpan value)
			{
				if (this.timeSpanBox == null)
					this.timeSpanBox = new StrongBox<TimeSpan>(FormatProvider);

				this.timeSpanBox.Store(value);
				return this.timeSpanBox;
			}
			private object Box(Guid value)
			{
				if (this.guidBox == null)
					this.guidBox = new StrongBox<Guid>(FormatProvider);

				this.guidBox.Store(value);
				return this.guidBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				else
				{
					if (this.falseBox == null)
						this.falseBox = new StrongBox<bool>(false, FormatProvider);
					return falseBox;
				}
			}

			private void DecrementClosingTokenCounter()
			{
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Pop();
					closingToken.Counter--;
					this.maps.Push(closingToken);
				}
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.inputStream.Dispose();
			}


			private enum MessagePackType : byte
			{
				PositiveFixIntStart = 0x00,
				PositiveFixIntEnd = 0x7f,
				FixMapStart = 0x80,
				FixMapEnd = 0x8f,
				FixArrayStart = 0x90,
				FixArrayEnd = 0x9f,
				FixStrStart = 0xa0,
				FixStrEnd = 0xbf,
				Nil = 0xc0,
				Unused = 0xc1,
				False = 0xc2,
				True = 0xc3,
				Bin8 = 0xc4,
				Bin16 = 0xc5,
				Bin32 = 0xc6,
				Ext8 = 0xc7,
				Ext16 = 0xc8,
				Ext32 = 0xc9,
				Float32 = 0xca,
				Float64 = 0xcb,
				UInt8 = 0xcc,
				UInt16 = 0xcd,
				UInt32 = 0xce,
				UInt64 = 0xcf,
				Int8 = 0xd0,
				Int16 = 0xd1,
				Int32 = 0xd2,
				Int64 = 0xd3,
				FixExt1 = 0xd4,
				FixExt2 = 0xd5,
				FixExt4 = 0xd6,
				FixExt8 = 0xd7,
				FixExt16 = 0xd8,
				Str8 = 0xd9,
				Str16 = 0xda,
				Str32 = 0xdb,
				Array16 = 0xdc,
				Array32 = 0xdd,
				Map16 = 0xde,
				Map32 = 0xdf,
				NegativeFixIntStart = 0xe0,
				NegativeFixIntEnd = 0xff
			}

			private enum MessagePackExtentionType : byte
			{
				None = 0,
				DateTime = 40,
				DateTimeOffset = 41,
				Decimal = 42
			}
		}
		#endregion

		#region Serialization: BSON
		private void ReadBson(GameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using (var patchBsonReader = new BsonReader(patchStream, leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchBsonReader.ReadDocument());
					}
				}
			}

			using(var bsonReader = new BsonReader(data, leaveOpen))
			{
				bsonReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private class BsonReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
			private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
			private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

			private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

			private struct Document
			{
				public readonly int Length;
				public readonly BsonType Type;
				public readonly int End;

				public Document(BsonType docType, int length, int end)
				{
					this.Type = docType;
					this.Length = length;
					this.End = end;
				}
			}

			private readonly Stream inputStream;
			private readonly bool leaveOpen;
			private readonly byte[] buffer;
			private readonly byte[] literalBuffer;
			private readonly EndianBitConverter bitConverter;
			private readonly Stack<Document> documents;
			private ReaderNode node;
			private int bufferOffset;
			private int bufferRead;
			private int bufferAvailable;
			private int totalBytesReaded;
			private BsonType memberType;

			private StrongBox<int> int32Box;
			private StrongBox<long> int64Box;
			private StrongBox<double> doubleBox;
			private StrongBox<decimal> decimalBox;
			private StrongBox<DateTime> dateBox;
			private StrongBox<DateTimeOffset> dateOffsetBox;
			private StrongBox<TimeSpan> timeSpanBox;
			private StrongBox<Guid> guidBox;
			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;

			public override int LineNumber { get { return 0; } }
			public override int ColumnNumber { get { return this.totalBytesReaded; } }
			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			public BsonReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (stream == null) throw new ArgumentNullException("stream");

				if (bufferSize < DEFAULT_BUFFER_SIZE)
					bufferSize = DEFAULT_BUFFER_SIZE;

				this.inputStream = stream;
				this.leaveOpen = leaveOpen;
				this.buffer = new byte[bufferSize];
				this.literalBuffer = new byte[bufferSize];
				this.bufferOffset = 0;
				this.bufferRead = 0;
				this.bufferAvailable = 0;
				this.bitConverter = EndianBitConverter.Little;
				this.documents = new Stack<Document>();
			}

			public override bool NextToken()
			{
				var length = 0;
				var end = 0;
				if (this.documents.Count == 0)
				{
					if (!this.ReadToBuffer(4, throwOnEos: false))
					{
						this.node = new ReaderNode(ReaderToken.EndOfStream);
						return false;
					}
					length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
					end = length <= 0 ? 0 : this.totalBytesReaded - this.bufferRead + length;
					var newDocument = new Document(BsonType.Document, length, end);
					this.documents.Push(newDocument);
					this.node = new ReaderNode(ReaderToken.BeginObject);
					return true;
				}

				var document = this.documents.Peek();
				if (this.memberType == BsonType.None)
				{
					this.ReadToBuffer(1, throwOnEos: true);
					memberType = (BsonType)this.buffer[this.bufferOffset];
					if (memberType != BsonType.None && document.Type == BsonType.Document)
					{
						var memberName = this.ReadCString();
						this.node = new ReaderNode(ReaderToken.Member, memberName);
						return true;
					}
					else if (memberType != BsonType.None)
					{
						this.SkipCString();
					}
				}

				var type = this.memberType;
				this.memberType = BsonType.None;
				switch (type)
				{
					case BsonType.Double:
						this.ReadToBuffer(8, throwOnEos: true);
						var doubleValue = this.bitConverter.ToDouble(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(doubleValue));
						return true;
					case BsonType.String:
						var stringValue = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, stringValue);
						return true;
					case BsonType.Array:
					case BsonType.Document:
						this.ReadToBuffer(4, throwOnEos: true);
						length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						end = length <= 0 ? 0 : this.totalBytesReaded - this.bufferRead + length;
						var newDocument = new Document(type, length, end);
						this.documents.Push(newDocument);
						this.node = new ReaderNode(type == BsonType.Document ? ReaderToken.BeginObject : ReaderToken.BeginArray);
						return true;
					case BsonType.Binary:
						const int GUID_SIZE = 16;
						const int DECIMAL_SIZE = 16;
						const int DATE_TIME_SIZE = 16;
						const int DATE_TIME_OFFSET_SIZE = 16;

						this.ReadToBuffer(5, throwOnEos: true);
						length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);

						if (length > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, length, MAX_BINARY_LENGTH);
						if (length < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var binaryType = (BsonBinaryType)this.buffer[this.bufferOffset + 4];
						switch (binaryType)
						{
							case BsonBinaryType.Decimal:
								if (length < DECIMAL_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var decimalValue = this.bitConverter.ToDecimal(this.buffer, this.bufferOffset);
								this.node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
								return true;
							case BsonBinaryType.DateTime:
								if (length < DATE_TIME_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var dateTime = new DateTime(this.bitConverter.ToInt64(this.buffer, this.bufferOffset + 1), (DateTimeKind)this.buffer[this.bufferOffset]);
								this.node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
								return true;
							case BsonBinaryType.DateTimeOffset:
								if (length < DATE_TIME_OFFSET_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var ticks = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
								var offsetTicks = this.bitConverter.ToInt64(this.buffer, this.bufferOffset + 8);
								var dateTimeOffset = new DateTimeOffset(ticks, new TimeSpan(offsetTicks));
								this.node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
								return true;
							case BsonBinaryType.UUID:
								if (length != GUID_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");

								unchecked
								{
									var guidValue = new Guid
									(
										(uint)(this.buffer[this.bufferOffset + 3] << 24 | this.buffer[this.bufferOffset + 2] << 16 | this.buffer[this.bufferOffset + 1] << 8 | this.buffer[this.bufferOffset + 0]),
										(ushort)(this.buffer[this.bufferOffset + 5] << 8 | this.buffer[this.bufferOffset + 4]),
										(ushort)(this.buffer[this.bufferOffset + 7] << 8 | this.buffer[this.bufferOffset + 6]),
										this.buffer[this.bufferOffset + 8],
										this.buffer[this.bufferOffset + 9],
										this.buffer[this.bufferOffset + 10],
										this.buffer[this.bufferOffset + 11],
										this.buffer[this.bufferOffset + 12],
										this.buffer[this.bufferOffset + 13],
										this.buffer[this.bufferOffset + 14],
										this.buffer[this.bufferOffset + 15]
									);

									this.node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
								}
								return true;
							case BsonBinaryType.Bytes:
							case BsonBinaryType.Function:
							case BsonBinaryType.BytesOld:
							case BsonBinaryType.UUIDOld:
							case BsonBinaryType.MD5:
							case BsonBinaryType.UserDefined:
							default:
								var bytes = this.ReadBytes(length, forceNewBuffer: true);
								this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
								return true;
						}
					case BsonType.Undefined:
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					case BsonType.ObjectId:
						var objectIdStr = this.ReadObjectId();
						this.node = new ReaderNode(ReaderToken.Value, objectIdStr);
						return true;
					case BsonType.Boolean:
						this.ReadToBuffer(1, throwOnEos: true);
						var boolValue = this.buffer[this.bufferOffset] > 0;
						this.node = new ReaderNode(ReaderToken.Value, this.Box(boolValue));
						return true;
					case BsonType.DateTime:
						this.ReadToBuffer(8, throwOnEos: true);
						var dateTimeMilliseconds = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(Epoch.AddTicks(checked(dateTimeMilliseconds * TimeSpan.TicksPerMillisecond))));
						return true;
					case BsonType.Null:
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					case BsonType.Regex:
						var regexPattern = this.ReadCString();
						var regexOptions = this.ReadCString();
						this.node = new ReaderNode(ReaderToken.Value, string.Concat("/", regexPattern, "/", regexOptions));
						return true;
					case BsonType.Reference:
						var reference = this.ReadUtf8String();
						var referenceId = this.ReadObjectId();
						this.node = new ReaderNode(ReaderToken.Value, reference + " -> " + referenceId);
						return true;
					case BsonType.JavaScript:
						var javascriptCode = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, javascriptCode);
						return true;
					case BsonType.JavaScriptWithScope:
						this.ReadToBuffer(4, throwOnEos: true);
						var javascriptScopedCode = this.ReadUtf8String();
						this.memberType = BsonType.Document;
						this.ReadAny(nextToken: false); // scope
						this.node = new ReaderNode(ReaderToken.Value, javascriptScopedCode);
						return true;
					case BsonType.Symbol:
						var symbolString = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, symbolString);
						return true;
					case BsonType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						var intValue = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(intValue));
						return true;
					case BsonType.Timestamp:
						this.ReadToBuffer(8, throwOnEos: true);
						var timestampSeconds = (this.bitConverter.ToInt64(this.buffer, this.bufferOffset) & uint.MaxValue);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(Epoch.AddTicks(checked(timestampSeconds * TimeSpan.TicksPerSecond))));
						return true;
					case BsonType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						var longValue = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(longValue));
						return true;
					case BsonType.MinKey:
						this.node = new ReaderNode(ReaderToken.Value, "min");
						return true;
					case BsonType.MaxKey:
						this.node = new ReaderNode(ReaderToken.Value, "max");
						return true;
					case BsonType.None:
						if (this.documents.Count == 0)
							goto default;

						document = this.documents.Pop();
						if (document.End != 0 && document.End != this.totalBytesReaded)
						{
							throw ReaderException.ReadingBrokenDocument(this, string.Format("invalid BSON document length '{0:##,###}' read, while actual size is '{1:##,###}'",
							document.Length, document.Length + (this.totalBytesReaded - document.End)));
						}
						this.node = new ReaderNode(document.Type == BsonType.Document ? ReaderToken.EndOfObject : ReaderToken.EndOfArray);
						return true;
					default:
						throw ReaderException.UnknownNotation(this, type.ToString());
				}
			}

			private void SkipCString()
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				var length = 0;
				var originalColumnNumber = this.totalBytesReaded;

				while (true)
				{
					while (this.bufferAvailable > 0)
					{
						var isTerminated = this.buffer[this.bufferOffset] == 0;

						length++;
						this.bufferOffset++;
						this.bufferAvailable--;

						if (isTerminated)
						{
							this.totalBytesReaded = originalColumnNumber + length; // length includes trailing zero
							return;
						}
					}

					this.bufferOffset = 0;
					this.bufferAvailable = 0;
					this.ReadToBuffer(this.buffer.Length, false);
					this.bufferRead = 0;
					if (this.bufferAvailable == 0)
						throw ReaderException.UnterminatedStringLiteral(this);
				}
			}
			private string ReadCString()
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				var literalBuffer = this.literalBuffer;
				var literalLength = 0;
				var literalOffset = 0;
				var originalColumnNumber = this.totalBytesReaded;
				while (true)
				{
					while (this.bufferAvailable > 0)
					{
						var isTerminated = this.buffer[this.bufferOffset] == 0;
						literalBuffer[literalOffset] = this.buffer[this.bufferOffset];

						literalOffset++;
						literalLength++;
						this.bufferOffset++;
						this.bufferAvailable--;

						if (isTerminated)
						{
							this.totalBytesReaded = originalColumnNumber + literalLength; // length includes trailing zero


							return Encoding.UTF8.GetString(literalBuffer, 0, literalLength - 1);
						}
						else if (literalOffset >= literalBuffer.Length)
						{
							Array.Resize(ref literalBuffer, (int)(literalBuffer.Length * 1.5));
						}
					}

					this.bufferOffset = 0;
					this.bufferAvailable = 0;
					this.ReadToBuffer(this.buffer.Length, false);
					this.bufferRead = 0;

					if (this.bufferAvailable == 0)
					{
						throw ReaderException.UnterminatedStringLiteral(this);
					}
				}
			}
			private string ReadUtf8String()
			{
				this.ReadToBuffer(4, throwOnEos: true);
				var length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);

				if (length > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, length, MAX_STRING_LENGTH);
				if (length < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of string literal");

				var strBytes = this.ReadBytes(length);


				return Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count - 1);
			}
			private string ReadObjectId()
			{
				this.ReadToBuffer(12, throwOnEos: true);

				var timeStamp = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
				var machineAndPid = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset + 4);
				var pidAndIncrement = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset + 8);
				var objectIdStr = string.Concat(timeStamp.ToString("X8"), machineAndPid.ToString("X8"), pidAndIncrement.ToString("X8"));

				return objectIdStr;
			}
			private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				if (this.bufferAvailable < bytesRequired)
				{
					if (this.bufferAvailable > 0)
						Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

					this.bufferOffset = 0;
					while (this.bufferAvailable < bytesRequired)
					{
						var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
						this.bufferAvailable += read;

						if (read != 0 || this.bufferAvailable >= bytesRequired)
							continue;

						if (throwOnEos)
							throw ReaderException.UnexpectedEndOfStream(this);
						else
							return false;
					}
				}

				this.bufferRead = bytesRequired;
				this.totalBytesReaded += bytesRequired;
				return true;
			}
			private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
			{
				if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException("bytesRequired");

				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
				{
					var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

					this.bufferAvailable -= (int)bytesRequired;
					this.bufferOffset += (int)bytesRequired;
					this.totalBytesReaded += (int)bytesRequired;

					return bytes;
				}
				else
				{
					var bytes = new byte[bytesRequired];
					var bytesOffset = 0;
					if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
					{
						var bytesToCopy = Math.Min(bytes.Length - bytesOffset, this.bufferAvailable);
						Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

						bytesOffset += bytesToCopy;
						this.bufferOffset += bytesToCopy;

						this.bufferAvailable -= bytesToCopy;
						this.totalBytesReaded += bytesToCopy;
					}

					if (this.bufferAvailable == 0)
						this.bufferOffset = 0;

					while (bytesOffset < bytes.Length)
					{
						var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

						bytesOffset += read;
						this.totalBytesReaded += read;

						if (read == 0 && bytesOffset < bytes.Length)
							throw ReaderException.UnexpectedEndOfStream(this);
					}

					return new ArraySegment<byte>(bytes, 0, bytes.Length);
				}
			}

			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);
				return this.dateBox;
			}
			private object Box(DateTimeOffset value)
			{
				if (this.dateOffsetBox == null)
					this.dateOffsetBox = new StrongBox<DateTimeOffset>(FormatProvider);

				this.dateOffsetBox.Store(value);
				return this.dateOffsetBox;
			}
			private object Box(TimeSpan value)
			{
				if (this.timeSpanBox == null)
					this.timeSpanBox = new StrongBox<TimeSpan>(FormatProvider);

				this.timeSpanBox.Store(value);
				return this.timeSpanBox;
			}
			private object Box(Guid value)
			{
				if (this.guidBox == null)
					this.guidBox = new StrongBox<Guid>(FormatProvider);

				this.guidBox.Store(value);
				return this.guidBox;
			}
			private object Box(int value)
			{
				if (this.int32Box == null)
					this.int32Box = new StrongBox<int>(FormatProvider);

				this.int32Box.Store(value);

				return this.int32Box;
			}
			private object Box(long value)
			{
				if (this.int64Box == null)
					this.int64Box = new StrongBox<long>(FormatProvider);

				this.int64Box.Store(value);

				return this.int64Box;
			}
			private object Box(double value)
			{
				if (this.doubleBox == null)
					this.doubleBox = new StrongBox<double>(FormatProvider);

				this.doubleBox.Store(value);

				return this.doubleBox;
			}
			private object Box(decimal value)
			{
				if (this.decimalBox == null)
					this.decimalBox = new StrongBox<decimal>(FormatProvider);

				this.decimalBox.Store(value);

				return this.decimalBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				else
				{
					if (this.falseBox == null)
						this.falseBox = new StrongBox<bool>(false, FormatProvider);
					return falseBox;
				}
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.inputStream.Dispose();
			}

			public enum BsonBinaryType
			{
				Bytes = 0,
				Function = 1,
				BytesOld = 2,
				UUIDOld = 3,
				UUID = 4,
				MD5 = 5,
				UserDefined = 80,

				// 16 bytes
				Decimal = 120,
				// 16 bytes
				DateTime = 121,
				// 16 bytes
				DateTimeOffset = 122,
			}

			public enum BsonType : byte
			{
				None = 0,
				Double = 1,
				String = 2,
				Document = 3,
				Array = 4,
				Binary = 5,
				Undefined = 6,
				ObjectId = 7,
				Boolean = 8,
				DateTime = 9,
				Null = 10,
				Regex = 11,
				Reference = 12,
				JavaScript = 13,
				Symbol = 14,
				JavaScriptWithScope = 15,
				Int32 = 16,
				Timestamp = 17,
				Int64 = 18,
				MinKey = 255,
				MaxKey = 127
			}
		}
		#endregion

		#region Serialization: XML
		private void ReadXml(GameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach (var patchStream in patches)
				{
					using (var patchXmlReader = new XmlFormattingReader(new StreamReader(patchStream, encoding), leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchXmlReader.ReadDocument());
					}
				}
			}

			using (var xmlReader = new XmlFormattingReader(new StreamReader(data, encoding), leaveOpen))
			{
				xmlReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private class XmlFormattingReader : Reader, IDisposable
		{
			private const int STATE_INITIAL = 0;
			private const int STATE_ARRAY = 1;
			private const int STATE_OBJECT = 2;
			private const int STATE_MEMBER = 3;
			private const int STATE_VALUE = 4;
			private const int STATE_ATTRIBUTE_MEMBER = 5;
			private const int STATE_ATTRIBUTE_VALUE = 6;
			private const int STATE_EMPTY = 7;

			private readonly XmlReader innerReader;
			private readonly bool leaveOpen;
			private readonly Stack<int> states;
			private string memberName;
			private ReaderNode node;

			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }
			public override int LineNumber { get { return this.innerReader is IXmlLineInfo ? ((IXmlLineInfo)this.innerReader).LineNumber : 0; } }
			public override int ColumnNumber { get { return this.innerReader is IXmlLineInfo ? ((IXmlLineInfo)this.innerReader).LinePosition : 0; } }

			public XmlFormattingReader(TextReader reader, bool leaveOpen = false)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				this.innerReader = new XmlTextReader(reader);
				this.leaveOpen = leaveOpen;
				this.states = new Stack<int>();
			}

			public override bool NextToken()
			{
				this.node = this.ReadNext();
				return this.node.Token != ReaderToken.EndOfStream;
			}

			private ReaderNode ReadNext()
			{
				var state = this.states.Count == 0 ? STATE_INITIAL : this.states.Peek();

				if (state == STATE_EMPTY)
					return this.ReadEmptyElement();

				if (state == STATE_ATTRIBUTE_MEMBER || state == STATE_ATTRIBUTE_VALUE)
					return this.ReadAttributes();

				while (this.innerReader.Read())
				{
					switch (this.innerReader.NodeType)
					{
						case XmlNodeType.Element:
							switch (this.innerReader.Name)
							{
								case XmlNotation.ValueElementName:
									if (state == STATE_OBJECT)
										goto default;
									if (state != STATE_INITIAL && state != STATE_ARRAY)
										throw this.NewUnknownNotationException();

									this.states.Push(STATE_VALUE);
									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return ReadNext();
								case XmlNotation.ArrayElementName:
									if (state == STATE_OBJECT)
										goto default;

									this.states.Push(STATE_ARRAY);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return new ReaderNode(ReaderToken.BeginArray);
								case XmlNotation.ObjectElementName:
									if (state == STATE_OBJECT)
										goto default;
									this.states.Push(STATE_OBJECT);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									if (this.innerReader.HasAttributes)
										this.states.Push(STATE_ATTRIBUTE_MEMBER);

									return new ReaderNode(ReaderToken.BeginObject);
								default:
									if (state != STATE_OBJECT)
										throw this.NewUnknownNotationException();

									this.memberName = XmlConvert.DecodeName(this.innerReader.Name);

									this.states.Push(STATE_MEMBER);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return new ReaderNode(ReaderToken.Member, this.memberName);
							}
						case XmlNodeType.EndElement:
							switch (state)
							{
								case STATE_VALUE:
									if (this.innerReader.Name != XmlNotation.ValueElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop VALUE
									return this.ReadNext();
								case STATE_MEMBER:
									this.states.Pop(); // pop MEMBER
									return this.ReadNext();
								case STATE_ARRAY:
									if (this.innerReader.Name != XmlNotation.ArrayElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop ARRAY
									return new ReaderNode(ReaderToken.EndOfArray);
								case STATE_OBJECT:
									if (this.innerReader.Name != XmlNotation.ObjectElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop OBJECT
									return new ReaderNode(ReaderToken.EndOfObject);
							}
							throw this.NewUnknownNotationException();
						case XmlNodeType.Text:
						case XmlNodeType.CDATA:
							if (state == STATE_VALUE || state == STATE_MEMBER)
								return new ReaderNode(ReaderToken.Value, this.innerReader.Value);
							throw this.NewUnknownNotationException();
						case XmlNodeType.SignificantWhitespace:
						case XmlNodeType.Whitespace:
						case XmlNodeType.Comment:
						case XmlNodeType.XmlDeclaration:
						case XmlNodeType.DocumentType:
						case XmlNodeType.Document:
							continue;
						case XmlNodeType.None:
						case XmlNodeType.EntityReference:
						case XmlNodeType.Entity:
						case XmlNodeType.EndEntity:
						case XmlNodeType.ProcessingInstruction:
						case XmlNodeType.DocumentFragment:
						case XmlNodeType.Notation:
						default:
							throw this.NewUnknownNotationException();
					}
				}

				return new ReaderNode(ReaderToken.EndOfStream);
			}

			private ReaderNode ReadEmptyElement()
			{
				this.states.Pop(); // pop EMPTY
				var state = this.states.Count > 0 ? this.states.Peek() : STATE_INITIAL;
				switch (state)
				{
					case STATE_MEMBER:
						this.states.Pop(); // pop MEMBER
						this.memberName = null;
						if (this.innerReader["nil", XmlNotation.XmlSchemaInstanceUrl] == XmlNotation.NullEntityTrue)
							return new ReaderNode(ReaderToken.Null);
						else
							return new ReaderNode(ReaderToken.Value, "");
					case STATE_VALUE:
						this.states.Pop(); // pop VALUE
						return new ReaderNode(ReaderToken.Null);
					case STATE_OBJECT:
						this.states.Pop(); // pop OBJECT
						return new ReaderNode(ReaderToken.EndOfObject);
					case STATE_ARRAY:
						this.states.Pop(); // pop ARRAY
						return new ReaderNode(ReaderToken.EndOfArray);
				}
				return this.ReadNext();
			}
			private ReaderNode ReadAttributes()
			{
				switch (this.states.Pop())
				{
					case STATE_ATTRIBUTE_MEMBER:
						while (this.innerReader.MoveToNextAttribute())
						{
							if (this.innerReader.Prefix == "xmlns" || this.innerReader.Prefix == "xsi")
								continue;

							this.states.Push(STATE_ATTRIBUTE_VALUE);
							return new ReaderNode(ReaderToken.Member, this.innerReader.Name);
						}
						break;
					case STATE_ATTRIBUTE_VALUE:
						this.states.Push(STATE_ATTRIBUTE_MEMBER);
						return new ReaderNode(ReaderToken.Value, this.innerReader.Value);
				}
				return this.ReadNext();
			}

			private Exception NewUnknownNotationException()
			{
				throw ReaderException.UnknownNotation(this, this.innerReader.NodeType.ToString() + "[" + this.innerReader.Name + "]");
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.innerReader.Close();
			}

			private class XmlNotation
			{
				public const string ObjectElementName = "Object";
				public const string ArrayElementName = "Array";
				public const string ValueElementName = "Value";

				public const string XmlSchemaInstanceUrl = "http://www.w3.org/2001/XMLSchema-instance";
				public const string NullEntityTrue = "true";
			}
		}
		#endregion

		#endregion
}

#pragma warning disable 0660, 0661
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public abstract partial class Document
	{
#pragma warning restore 0660, 0661
		public static bool operator ==(Document value1, Document value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2,null)) return false;

			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Document value1, Document value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2,null)) return true;

			return Object.Equals(value1, value2) == false;
		}

		protected internal abstract void Apply(GameData.Visitor visitor);

		protected internal abstract void Init(GameData gameData, string languageId);

		protected internal abstract void SetLanguage(string languageId);

		protected static bool AreEquals<T>(T value1, T value2)
		{
			if (value1 == null) return value2 == null;

			return value1.Equals(value2);
		}
		protected static bool AreEquals<T>(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2))
				return true;
			else if (value1 == null || value2 == null)
				return false;

			if (value1.Equals(value2))
				return true;

			return Enumerable.SequenceEqual(value1, value2);
		}

		protected static void EmptyIfNull<T>(ref ReadOnlyList<T> list)
		{
			if (list == null || list.Count == 0)
				list = ReadOnlyList<T>.Empty;
		}

		protected static ReadOnlyList<T> DereferenceCollection<T>(ReadOnlyList<DocumentReference<T>> collection, ref ReadOnlyList<T> dereferencedCollection) where T : Document
		{
			if (dereferencedCollection != null) {
				return dereferencedCollection;
			}

			if (collection.Count == 0) {
				dereferencedCollection = ReadOnlyList<T>.Empty;
				return dereferencedCollection;
			}

			var list = new List<T>(collection.Count);
			for(var i = 0; i < collection.Count; i++)
				list.Add(collection[i].Value);

			dereferencedCollection = new ReadOnlyList<T>(list);
			return dereferencedCollection;
		}


		protected static int GetHashCodeFor<T>(T value)
		{
			if (value == null) return 0;
			return value.GetHashCode();
		}
		protected static int GetHashCodeFor<T>(ReadOnlyList<T> value)
		{
			if (value == null)
				return 0;

			if (value.Count == 0)
				return value.GetHashCode();

			var hashCode = 0;
			foreach (var item in value)
				hashCode = unchecked(hashCode + item.GetHashCode());
			return hashCode;
		}
	}
		[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
		public sealed partial class DocumentReference<T> where T : Document
		{	
			[NonSerialized]
			private T value;
			[NonSerialized]
			private Func<string, object, Document> valueResolver;
			
			public object Id { get; set; }

			public T Value
			{
				get
				{
					if (this.value != null)
						return value;

					if (this.valueResolver != null)
						return this.value = (T)this.valueResolver(typeof(T).Name, this.Id);
					else
						throw new InvalidOperationException(string.Format("Broken {0} reference with id {1}. Consider calling Resolve() before using Value.", typeof(T).Name, this.Id));
				}
			}

			public static implicit operator T(DocumentReference<T> reference)
			{
				return reference.Value;
			}

			internal void Resolve(Func<string, object, Document> resolver)
			{
				if (resolver == null) throw new ArgumentNullException("resolver");

	#pragma warning disable 0162 // C# Unreachable code detected
				this.value = null;
				// ReSharper disable once ConditionIsAlwaysTrueOrFalse
				if (false)
					this.valueResolver = resolver;
				else
					this.value = (T)resolver(typeof(T).Name, this.Id);
	#pragma warning restore 0162
			}

			public override bool Equals(object value)
			{
				var other = value as DocumentReference<T>;
				if (other == null)
					return false;
				else if (Object.ReferenceEquals(this, value))
					return true;

				return Object.Equals(this.Id, other.Id);
			}

			public override int GetHashCode()
			{
				var hashCode = (this.Id != null ? this.Id.GetHashCode() : 0);
				return hashCode;
			}

			public static DocumentReference<T> Create(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var idValue = default(object);
				if (values.TryGetValue("Id", out idValue) == false || idValue == null)
				{
					return null;
				}

				return new DocumentReference<T> { Id = idValue };
			}

			public override string ToString()
			{
				return string.Format("id: {0}, entity: {1}", this.Id, typeof(T).Name);
			}
		}

		[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
		public sealed partial class LocalizedString : IDictionary<string, string>
		{
			private static readonly string[] DefaultLanguageIds = new string[] { "en-US" };
			private static readonly StringComparer KeyComparer = StringComparer.OrdinalIgnoreCase;

			private string[] keys;
			private string[] values;
			private string currentValue;
			private string currentLanguageId;
			private bool isReadOnly;

			public string Value { get { return this.currentValue ?? this.values.FirstOrDefault(v => v != null); } }
			public string CurrentLanguageId { get { return this.currentLanguageId; } }
			public string this[string key]
			{
				get
				{
					var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
					return languageIndex < 0 ? null : this.values[languageIndex];
				}
				set
				{
					this.ThrowIfReadOnly();
					var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
					if (languageIndex >= 0)
					{
						this.values[languageIndex] = value;
						return;
					}

					Array.Resize(ref this.keys, this.keys.Length + 1);
					Array.Resize(ref this.values, this.values.Length + 1);
					this.keys[this.keys.Length - 1] = key;
					this.values[this.keys.Length - 1] = value;
					Array.Sort(this.keys, this.values, KeyComparer);
				}
			}

			public LocalizedString()
			{
				this.keys = DefaultLanguageIds;
				this.values = new string[DefaultLanguageIds.Length];
			}

			public void SetLanguage(string languageId)
			{
				if (languageId == null) throw new ArgumentNullException("languageId");

				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, languageId, KeyComparer);
				if (languageIndex < 0)
				{
					System.Diagnostics.Debug.WriteLine(string.Format("Localized string '{0}' doesn't contains text for '{1}' language.", string.Join(", ", this.keys), languageId));
					this.currentValue = string.Empty;
				}
				else
				{
					this.currentValue = this.values[languageIndex];
				}

				this.currentLanguageId = languageId;
			}
			public void SetReadOnly()
			{
				this.isReadOnly = true;
			}

			public static implicit operator string(LocalizedString str)
			{
				if (str == null) return null;
				return str.Value;
			}

			public override bool Equals(object value)
			{
				var other = value as LocalizedString;
				if (other == null)
					return false;
				else if (object.ReferenceEquals(this, value))
					return true;
				else if (this.keys.Length != other.keys.Length)
					return false;

				for (var i = 0; i < this.keys.Length; i++)
				{
					if (KeyComparer.Equals(this.keys[i], other.keys[i]) == false)
					{
						return false;
					}

					if (string.Equals(this.values[i], other.values[i], StringComparison.OrdinalIgnoreCase) == false)
					{
						return false;
					}
				}

				return true;
			}

			public override int GetHashCode()
			{
				var hashCode = 0;
				foreach (var value in this.values)
					hashCode += unchecked((value ?? "").GetHashCode());
				return hashCode;
			}

			ICollection<string> IDictionary<string, string>.Keys { get { return this.keys; } }
			ICollection<string> IDictionary<string, string>.Values { get { return this.values; } }
			int ICollection<KeyValuePair<string, string>>.Count { get { return this.keys.Length; } }
			bool ICollection<KeyValuePair<string, string>>.IsReadOnly { get { return this.isReadOnly; } }

			void IDictionary<string, string>.Add(string key, string value)
			{
				((IDictionary<string, string>)this)[key] = value;
			}
			bool IDictionary<string, string>.ContainsKey(string key)
			{
				return Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer) >= 0;
			}
			bool IDictionary<string, string>.Remove(string key)
			{
				if (((IDictionary<string, string>)this).ContainsKey(key))
				{
					((IDictionary<string, string>)this)[key] = null;
					return true;
				}
				return false;
			}
			bool IDictionary<string, string>.TryGetValue(string key, out string value)
			{
				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
				if (languageIndex >= 0)
				{
					value = this.values[languageIndex];
					return value != null;
				}
				else
				{
					value = null;
					return false;
				}
			}

			void ICollection<KeyValuePair<string, string>>.Add(KeyValuePair<string, string> item)
			{
				((IDictionary<string, string>)this)[item.Key] = item.Value;
			}
			void ICollection<KeyValuePair<string, string>>.Clear()
			{
				this.ThrowIfReadOnly();

				Array.Clear(this.values, 0, this.values.Length);
			}
			bool ICollection<KeyValuePair<string, string>>.Contains(KeyValuePair<string, string> item)
			{
				return string.Equals(((IDictionary<string, string>)this)[item.Key], item.Value, StringComparison.Ordinal);
			}
			void ICollection<KeyValuePair<string, string>>.CopyTo(KeyValuePair<string, string>[] array, int arrayIndex)
			{
				var offset = 0;
				for (var i = arrayIndex; i < array.Length; i++)
				{
					array[i] = new KeyValuePair<string, string>(this.keys[offset], this.values[offset]);
					offset++;
				}
			}
			bool ICollection<KeyValuePair<string, string>>.Remove(KeyValuePair<string, string> item)
			{
				this.ThrowIfReadOnly();
				if (((ICollection<KeyValuePair<string, string>>)this).Contains(item))
				{
					return ((IDictionary<string, string>)this).Remove(item.Key);
				}

				return false;
			}
			IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
			{
				for (var i = 0; i < this.keys.Length; i++)
				{
					yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
				}
			}

			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				for (var i = 0; i < this.keys.Length; i++)
				{
					yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
				}
			}

			private void ThrowIfReadOnly()
			{
				if (this.isReadOnly)
					throw new InvalidOperationException("This LocalizedString is read-only and can't be changed.");
			}

			public static bool operator ==(LocalizedString value1, LocalizedString value2)
			{
				return object.Equals(value1, value2);
			}
			public static bool operator !=(LocalizedString value1, LocalizedString value2)
			{
				return object.Equals(value1, value2) == false;
			}

			public static LocalizedString Create(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var value = new LocalizedString();
				foreach(var kv in values)
				{
					if (kv.Key == "notes")
					{
						continue;
					}

					value[kv.Key] = kv.Value != null ? kv.Value.ToString() : null;
				}
				return value;
			}

			public override string ToString()
			{
				return this.Value;
			}
		}
		
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public class ReadOnlyList<T> : IList<T>
	{
		public static readonly ReadOnlyList<T> Empty = new ReadOnlyList<T>();

		private static readonly List<T> EmptyList = new List<T>();

		private readonly List<T> list;

		private List<T> InnerList { get { return this.list ?? EmptyList; } }

		/// <inheritdoc />
		public int Count { get { return this.InnerList.Count; } }
		/// <inheritdoc />
		public bool IsReadOnly { get { return true; } }
		/// <inheritdoc />
		public T this[int index] { get { return this.InnerList[index]; } set { throw new NotSupportedException(); } }

		public ReadOnlyList()
		{
			this.list = null;
		}

		public ReadOnlyList(List<T> list)
		{
			this.list = list;
		}

		public bool Contains(T item) { return this.InnerList.Contains(item); }
		/// <inheritdoc />
		public void CopyTo(T[] array, int arrayIndex) { this.InnerList.CopyTo(array, arrayIndex); }
		public void ForEach(Action<T> action) { this.InnerList.ForEach(action); }
		public T Find(Predicate<T> match) { return this.InnerList.Find(match); }
		public bool Exists(Predicate<T> match) { return this.InnerList.Exists(match); }
		public int FindIndex(Predicate<T> match) { return this.InnerList.FindIndex(match); }
		public int FindIndex(int startIndex, Predicate<T> match) { return this.InnerList.FindIndex(startIndex, match); }
		public int FindIndex(int startIndex, int count, Predicate<T> match) { return this.InnerList.FindIndex(startIndex, count, match); }
		public T FindLast(Predicate<T> match) { return this.InnerList.FindLast(match); }
		public int FindLastIndex(Predicate<T> match) { return this.InnerList.FindLastIndex(match); }
		public int FindLastIndex(int startIndex, Predicate<T> match) { return this.InnerList.FindLastIndex(startIndex, match); }
		public int FindLastIndex(int startIndex, int count, Predicate<T> match) { return this.InnerList.FindLastIndex(startIndex, count, match); }
		public int IndexOf(T item) { return this.InnerList.IndexOf(item); }
		public int IndexOf(T item, int index) { return this.InnerList.IndexOf(item, index); }
		public int IndexOf(T item, int index, int count) { return this.InnerList.IndexOf(item, index, count); }
		public int LastIndexOf(T item) { return this.InnerList.LastIndexOf(item); }
		public int LastIndexOf(T item, int index) { return this.InnerList.LastIndexOf(item, index); }
		public int LastIndexOf(T item, int index, int count) { return this.InnerList.LastIndexOf(item, index, count); }
		public bool TrueForAll(Predicate<T> match) { return this.InnerList.TrueForAll(match); }
		public List<T> GetRange(int index, int count) { return this.InnerList.GetRange(index, count); }
		public List<T> FindAll(Predicate<T> match) { return this.InnerList.FindAll(match); }
		public T[] ToArray() { return this.InnerList.ToArray(); }
		public List<T> ToList() { return new List<T>(this.InnerList); }
		public List<TOutput> ConvertAll<TOutput>(Converter<T, TOutput> converter) { return this.InnerList.ConvertAll(converter); }

		public List<T>.Enumerator GetEnumerator()
		{
			return this.InnerList.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerList.GetEnumerator();
		}
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerList.GetEnumerator();
		}

		public override bool Equals(object obj)
		{
			var otherList = obj as ReadOnlyList<T>;
			if (Object.ReferenceEquals(this, obj))
				return true;
			else if (otherList != null && this.Count == otherList.Count)
				return Enumerable.SequenceEqual(this.list, otherList.list);
			else
				return Object.Equals(this.list, obj);
		}
		public override int GetHashCode()
		{
			return this.InnerList.GetHashCode();
		}

		public static bool operator ==(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return false;

			return value1.Equals(value2);
		}
		public static bool operator !=(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return true;

			return value1.Equals(value2) == false;
		}

		#region NotSupported
		/// <inheritdoc />
		public void Insert(int index, T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public bool Remove(T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void Add(T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void Clear()
		{
			throw new NotSupportedException();
		}
		#endregion

		public static ReadOnlyList<T> Create(List<T> list)
		{
			if (list == null)
			{
				return Empty;
			}
			else
			{
				return new ReadOnlyList<T>(list);
			}
		}

		public override string ToString()
		{
			return this.InnerList.Count.ToString();
		}
	}

	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public class ReadOnlyDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>
	{
		public static readonly ReadOnlyDictionary<KeyT, ValueT> Empty = new ReadOnlyDictionary<KeyT, ValueT>();

		private static readonly Dictionary<KeyT, ValueT> EmptyDictionary = new Dictionary<KeyT, ValueT>();

		private readonly Dictionary<KeyT, ValueT> dictionary;

		private Dictionary<KeyT, ValueT> InnerDictionary { get { return this.dictionary ?? EmptyDictionary; } }
		/// <inheritdoc />
		public int Count { get { return this.InnerDictionary.Count; } }
		/// <inheritdoc />
		public bool IsReadOnly { get { return true; } }
		public ValueT this[KeyT key] { get { return this.dictionary[key]; } set { throw new NotSupportedException();} }
		public Dictionary<KeyT, ValueT>.KeyCollection Keys { get { return this.InnerDictionary.Keys; } }
		public Dictionary<KeyT, ValueT>.ValueCollection Values { get { return this.InnerDictionary.Values; } }
		/// <inheritdoc />
		ICollection<ValueT> IDictionary<KeyT, ValueT>.Values { get { return this.Values; } }
		/// <inheritdoc />
		ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys { get { return this.Keys; } }
		public IEqualityComparer<KeyT> Comparer { get { return this.InnerDictionary.Comparer; } }

		public ReadOnlyDictionary()
		{
			this.dictionary = null;
		}

		public ReadOnlyDictionary(Dictionary<KeyT, ValueT> dictionary)
		{
			this.dictionary = dictionary;
		}
		/// <inheritdoc />
		public bool Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return ((ICollection<KeyValuePair<KeyT, ValueT>>)this.InnerDictionary).Contains(item);
		}
		public void CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			((ICollection<KeyValuePair<KeyT, ValueT>>)this.InnerDictionary).CopyTo(array, arrayIndex);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.InnerDictionary.ContainsKey(key);
		}
		public bool ContainsValue(ValueT value)
		{
			return this.InnerDictionary.ContainsValue(value);
		}
		public Dictionary<KeyT, ValueT> ToDictionary()
		{
			return new Dictionary<KeyT, ValueT>(this.InnerDictionary);
		}
		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.InnerDictionary.TryGetValue(key, out value);
		}
	
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerDictionary.GetEnumerator();
		}
		public Dictionary<KeyT, ValueT>.Enumerator GetEnumerator()
		{
			return this.InnerDictionary.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerDictionary.GetEnumerator();
		}

		public override bool Equals(object obj)
		{
			var otherReadOnlyDictionary = obj as ReadOnlyDictionary<KeyT, ValueT>;
			var otherDictionary = obj as Dictionary<KeyT, ValueT>;
			if (Object.ReferenceEquals(this, obj))
				return true;
			else if (otherReadOnlyDictionary != null && this.Count == otherReadOnlyDictionary.Count)
				return Enumerable.SequenceEqual(this.dictionary, otherReadOnlyDictionary.dictionary);
			else if (otherDictionary != null && this.Count == otherDictionary.Count)
				return Enumerable.SequenceEqual(this.dictionary, otherDictionary);
			else
				return Object.Equals(this.dictionary, obj);
		}
		public override int GetHashCode()
		{
			return this.InnerDictionary.GetHashCode();
		}

		public static bool operator ==(ReadOnlyDictionary<KeyT, ValueT> value1, ReadOnlyDictionary<KeyT, ValueT> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return false;

			return value1.Equals(value2);
		}
		public static bool operator !=(ReadOnlyDictionary<KeyT, ValueT> value1, ReadOnlyDictionary<KeyT, ValueT> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return true;

			return value1.Equals(value2) == false;
		}

		#region NotSupported

		/// <inheritdoc />
		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			throw new NotSupportedException();
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.Clear()
		{
			throw new NotSupportedException();
		}

		/// <inheritdoc />
		void IDictionary<KeyT, ValueT>.Add(KeyT key, ValueT value)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		bool IDictionary<KeyT, ValueT>.Remove(KeyT key)
		{
			throw new NotSupportedException();
		}

		#endregion

		public static ReadOnlyDictionary<KeyT, ValueT> Create(Dictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null)
			{
				return Empty;
			}
			else
			{
				return new  ReadOnlyDictionary<KeyT, ValueT>(dictionary);
			}
		}

		public override string ToString()
		{
			return this.InnerDictionary.Count.ToString();
		}
	}

}

